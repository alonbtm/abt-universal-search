{"version":3,"file":"RateLimiter.js","sourceRoot":"","sources":["../../src/security/RateLimiter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Rate Limiter - Sliding window rate limiting with token bucket algorithm\n * @description Implements configurable rate limiting with per-client and per-data-source quotas\n */\n\nimport { \n  RateLimitConfig, \n  RateLimitResult, \n  ClientRateState, \n  RateLimitingMetrics,\n  IRateLimiter,\n  RateLimitEvent,\n  RateLimitEventType\n} from '../types/RateLimiting.js';\n\n/**\n * Default rate limiting configuration\n */\nconst DEFAULT_CONFIG: RateLimitConfig = {\n  requestsPerWindow: 60,\n  windowSizeMs: 60000, // 1 minute\n  burstCapacity: 10,\n  refillRate: 1, // 1 token per second\n  useSlidingWindow: true,\n  perDataSource: {}\n};\n\n/**\n * Sliding window rate limiter with token bucket algorithm\n */\nexport class RateLimiter implements IRateLimiter {\n  private config: RateLimitConfig;\n  private clientStates: Map<string, ClientRateState>;\n  private dataSourceConfigs: Map<string, RateLimitConfig>;\n  private metrics: RateLimitingMetrics;\n  private eventCallbacks: Array<(event: RateLimitEvent) => void>;\n  private cleanupInterval: NodeJS.Timeout | null;\n\n  constructor(config: Partial<RateLimitConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.clientStates = new Map();\n    this.dataSourceConfigs = new Map();\n    this.eventCallbacks = [];\n    this.cleanupInterval = null;\n    \n    // Initialize metrics\n    this.metrics = {\n      totalRequests: 0,\n      blockedRequests: 0,\n      deduplicatedRequests: 0,\n      circuitBreakerTrips: 0,\n      avgProcessingTime: 0,\n      activeClients: 0,\n      abuseIncidents: 0,\n      degradationActivations: 0,\n      performance: {\n        rateLimitCheckTime: 0,\n        deduplicationTime: 0,\n        fingerprintingTime: 0,\n        memoryUsage: 0\n      }\n    };\n\n    // Initialize per-data-source configs\n    if (this.config.perDataSource) {\n      for (const [dataSource, dsConfig] of Object.entries(this.config.perDataSource)) {\n        this.dataSourceConfigs.set(dataSource, { ...this.config, ...dsConfig });\n      }\n    }\n\n    // Start cleanup interval\n    this.startCleanup();\n  }\n\n  /**\n   * Check if request is within rate limits\n   */\n  async checkLimit(clientId: string, query: string, dataSource?: string): Promise<RateLimitResult> {\n    const startTime = performance.now();\n    \n    try {\n      this.metrics.totalRequests++;\n      \n      // Get applicable configuration\n      const config = this.getConfigForDataSource(dataSource);\n      \n      // Get or create client state\n      const clientState = this.getOrCreateClientState(clientId);\n      \n      // Update metrics\n      this.updateActiveClientsCount();\n      \n      // Check sliding window limit\n      const slidingWindowResult = this.checkSlidingWindow(clientState, config);\n      \n      // Check token bucket limit\n      const tokenBucketResult = this.checkTokenBucket(clientState, config);\n      \n      // Determine final result (most restrictive)\n      const finalResult = this.combineResults(slidingWindowResult, tokenBucketResult, config);\n      \n      // Record metrics\n      if (!finalResult.allowed) {\n        this.metrics.blockedRequests++;\n        this.emitEvent('rate_limit_exceeded', clientId, { rateLimit: finalResult });\n      } else if (finalResult.remainingRequests <= config.requestsPerWindow * 0.1) {\n        this.emitEvent('rate_limit_warning', clientId, { rateLimit: finalResult });\n      }\n      \n      // Update performance metrics\n      const processingTime = performance.now() - startTime;\n      this.updatePerformanceMetrics('rateLimitCheckTime', processingTime);\n      \n      return finalResult;\n      \n    } catch (error) {\n      // Fail open - allow request if rate limiting fails\n      console.error('Rate limiting error:', error);\n      return {\n        allowed: true,\n        remainingRequests: this.config.requestsPerWindow,\n        resetTime: Date.now() + this.config.windowSizeMs,\n        windowStart: Date.now(),\n        appliedLimit: dataSource || 'default',\n        retryAfter: 0\n      };\n    }\n  }\n\n  /**\n   * Record successful/failed request execution\n   */\n  recordRequest(clientId: string, query: string, success: boolean): void {\n    const clientState = this.clientStates.get(clientId);\n    if (!clientState) return;\n\n    // Update request timestamps\n    const now = Date.now();\n    clientState.lastRequestTime = now;\n    clientState.totalRequests++;\n\n    // Clean old timestamps from sliding window\n    this.cleanSlidingWindow(clientState);\n    \n    // Add current request timestamp\n    clientState.requestTimestamps.push(now);\n\n    // Update failure tracking for circuit breaker integration\n    if (!success) {\n      // Could emit event for circuit breaker\n      this.emitEvent('rate_limit_reset', clientId, {});\n    }\n  }\n\n  /**\n   * Get remaining quota for client\n   */\n  getRemainingQuota(clientId: string): RateLimitResult {\n    const clientState = this.clientStates.get(clientId);\n    if (!clientState) {\n      return {\n        allowed: true,\n        remainingRequests: this.config.requestsPerWindow,\n        resetTime: Date.now() + this.config.windowSizeMs,\n        windowStart: Date.now(),\n        appliedLimit: 'default'\n      };\n    }\n\n    this.cleanSlidingWindow(clientState);\n    const remainingRequests = Math.max(0, this.config.requestsPerWindow - clientState.requestTimestamps.length);\n    const remainingTokens = Math.floor(clientState.tokens);\n    \n    return {\n      allowed: remainingRequests > 0 && remainingTokens > 0,\n      remainingRequests: Math.min(remainingRequests, remainingTokens),\n      resetTime: this.getWindowResetTime(clientState),\n      windowStart: clientState.firstRequestTime,\n      appliedLimit: 'default'\n    };\n  }\n\n  /**\n   * Reset rate limit state for client\n   */\n  resetClient(clientId: string): void {\n    const clientState = this.clientStates.get(clientId);\n    if (clientState) {\n      clientState.requestTimestamps = [];\n      clientState.tokens = this.config.burstCapacity || this.config.requestsPerWindow;\n      clientState.lastRefill = Date.now();\n      \n      this.emitEvent('rate_limit_reset', clientId, {});\n    }\n  }\n\n  /**\n   * Get comprehensive rate limiting metrics\n   */\n  getMetrics(): RateLimitingMetrics {\n    this.updateMemoryUsage();\n    return { ...this.metrics };\n  }\n\n  /**\n   * Update rate limiting configuration\n   */\n  updateConfig(config: Partial<RateLimitConfig>): void {\n    this.config = { ...this.config, ...config };\n    \n    // Update per-data-source configs\n    if (config.perDataSource) {\n      this.dataSourceConfigs.clear();\n      for (const [dataSource, dsConfig] of Object.entries(config.perDataSource)) {\n        this.dataSourceConfigs.set(dataSource, { ...this.config, ...dsConfig });\n      }\n    }\n  }\n\n  /**\n   * Add event callback\n   */\n  onEvent(callback: (event: RateLimitEvent) => void): void {\n    this.eventCallbacks.push(callback);\n  }\n\n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n    this.clientStates.clear();\n    this.dataSourceConfigs.clear();\n    this.eventCallbacks.length = 0;\n  }\n\n  // Private implementation methods\n\n  private getConfigForDataSource(dataSource?: string): RateLimitConfig {\n    if (dataSource && this.dataSourceConfigs.has(dataSource)) {\n      return this.dataSourceConfigs.get(dataSource)!;\n    }\n    return this.config;\n  }\n\n  private getOrCreateClientState(clientId: string): ClientRateState {\n    let clientState = this.clientStates.get(clientId);\n    \n    if (!clientState) {\n      const now = Date.now();\n      clientState = {\n        clientId,\n        requestTimestamps: [],\n        tokens: this.config.burstCapacity || this.config.requestsPerWindow,\n        lastRefill: now,\n        totalRequests: 0,\n        firstRequestTime: now,\n        lastRequestTime: now\n      };\n      this.clientStates.set(clientId, clientState);\n    }\n    \n    return clientState;\n  }\n\n  private checkSlidingWindow(clientState: ClientRateState, config: RateLimitConfig): RateLimitResult {\n    this.cleanSlidingWindow(clientState, config);\n    \n    const requestCount = clientState.requestTimestamps.length;\n    const remainingRequests = Math.max(0, config.requestsPerWindow - requestCount);\n    const allowed = requestCount < config.requestsPerWindow;\n    \n    return {\n      allowed,\n      remainingRequests,\n      resetTime: this.getWindowResetTime(clientState, config),\n      windowStart: clientState.requestTimestamps[0] || Date.now(),\n      appliedLimit: 'sliding_window',\n      retryAfter: allowed ? 0 : Math.ceil(config.windowSizeMs / 1000)\n    };\n  }\n\n  private checkTokenBucket(clientState: ClientRateState, config: RateLimitConfig): RateLimitResult {\n    this.refillTokens(clientState, config);\n    \n    const hasTokens = clientState.tokens >= 1;\n    const remainingTokens = Math.floor(clientState.tokens);\n    \n    if (hasTokens) {\n      clientState.tokens -= 1;\n    }\n    \n    return {\n      allowed: hasTokens,\n      remainingRequests: remainingTokens,\n      resetTime: this.getTokenRefillTime(clientState, config),\n      windowStart: clientState.firstRequestTime,\n      appliedLimit: 'token_bucket',\n      retryAfter: hasTokens ? 0 : Math.ceil(1 / (config.refillRate || 1))\n    };\n  }\n\n  private combineResults(slidingResult: RateLimitResult, tokenResult: RateLimitResult, config: RateLimitConfig): RateLimitResult {\n    // Use sliding window if enabled, otherwise use token bucket\n    if (config.useSlidingWindow) {\n      // Both limits must pass\n      const allowed = slidingResult.allowed && tokenResult.allowed;\n      return {\n        allowed,\n        remainingRequests: Math.min(slidingResult.remainingRequests, tokenResult.remainingRequests),\n        resetTime: Math.max(slidingResult.resetTime, tokenResult.resetTime),\n        windowStart: slidingResult.windowStart,\n        appliedLimit: allowed ? slidingResult.appliedLimit : (slidingResult.allowed ? tokenResult.appliedLimit : slidingResult.appliedLimit),\n        retryAfter: allowed ? 0 : Math.max(slidingResult.retryAfter || 0, tokenResult.retryAfter || 0)\n      };\n    } else {\n      return tokenResult;\n    }\n  }\n\n  private cleanSlidingWindow(clientState: ClientRateState, config?: RateLimitConfig): void {\n    const windowSize = (config || this.config).windowSizeMs;\n    const cutoffTime = Date.now() - windowSize;\n    \n    // Remove timestamps outside the sliding window\n    clientState.requestTimestamps = clientState.requestTimestamps.filter(\n      timestamp => timestamp > cutoffTime\n    );\n  }\n\n  private refillTokens(clientState: ClientRateState, config: RateLimitConfig): void {\n    const now = Date.now();\n    const timeSinceLastRefill = now - clientState.lastRefill;\n    const tokensToAdd = (timeSinceLastRefill / 1000) * (config.refillRate || 1);\n    \n    if (tokensToAdd > 0) {\n      const maxTokens = config.burstCapacity || config.requestsPerWindow;\n      clientState.tokens = Math.min(maxTokens, clientState.tokens + tokensToAdd);\n      clientState.lastRefill = now;\n    }\n  }\n\n  private getWindowResetTime(clientState: ClientRateState, config?: RateLimitConfig): number {\n    const windowSize = (config || this.config).windowSizeMs;\n    if (clientState.requestTimestamps.length === 0) {\n      return Date.now() + windowSize;\n    }\n    return clientState.requestTimestamps[0] + windowSize;\n  }\n\n  private getTokenRefillTime(clientState: ClientRateState, config: RateLimitConfig): number {\n    const refillRate = config.refillRate || 1;\n    return clientState.lastRefill + (1000 / refillRate);\n  }\n\n  private updateActiveClientsCount(): void {\n    this.metrics.activeClients = this.clientStates.size;\n  }\n\n  private updatePerformanceMetrics(metric: keyof RateLimitingMetrics['performance'], value: number): void {\n    // Simple exponential moving average\n    const alpha = 0.1;\n    this.metrics.performance[metric] = (1 - alpha) * this.metrics.performance[metric] + alpha * value;\n  }\n\n  private updateMemoryUsage(): void {\n    // Estimate memory usage\n    const clientStatesSize = this.clientStates.size * 200; // Rough estimate per client state\n    const configSize = JSON.stringify(this.config).length;\n    this.metrics.performance.memoryUsage = clientStatesSize + configSize;\n  }\n\n  private emitEvent(type: RateLimitEventType, clientId: string, data: any): void {\n    const event: RateLimitEvent = {\n      type,\n      timestamp: Date.now(),\n      clientId,\n      data\n    };\n\n    this.eventCallbacks.forEach(callback => {\n      try {\n        callback(event);\n      } catch (error) {\n        console.error('Rate limiting event callback error:', error);\n      }\n    });\n  }\n\n  private startCleanup(): void {\n    // Clean up old client states every 5 minutes\n    this.cleanupInterval = setInterval(() => {\n      const cutoffTime = Date.now() - (this.config.windowSizeMs * 2); // Keep data for 2x window size\n      \n      for (const [clientId, clientState] of this.clientStates.entries()) {\n        if (clientState.lastRequestTime < cutoffTime) {\n          this.clientStates.delete(clientId);\n        }\n      }\n      \n      this.updateActiveClientsCount();\n    }, 5 * 60 * 1000); // 5 minutes\n  }\n}\n\n/**\n * Factory function for creating rate limiter instances\n */\nexport function createRateLimiter(config?: Partial<RateLimitConfig>): IRateLimiter {\n  return new RateLimiter(config);\n}\n\n/**\n * Utility function for checking if a rate limit result indicates throttling\n */\nexport function isThrottled(result: RateLimitResult): boolean {\n  return !result.allowed;\n}\n\n/**\n * Utility function for getting retry delay from rate limit result\n */\nexport function getRetryDelay(result: RateLimitResult): number {\n  return result.retryAfter || 0;\n}\n\n/**\n * Utility function for formatting rate limit status for user display\n */\nexport function formatRateLimitStatus(result: RateLimitResult): string {\n  if (result.allowed) {\n    return `${result.remainingRequests} requests remaining`;\n  } else {\n    const retryAfter = result.retryAfter || 0;\n    if (retryAfter > 0) {\n      return `Rate limited. Try again in ${retryAfter} seconds`;\n    } else {\n      return 'Rate limited. Please try again later';\n    }\n  }\n}"]}