<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bearer Token Authentication Example - Universal Search Component</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .example-section {
            margin: 30px 0;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f9f9f9;
        }
        .security-warning {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
        }
        .config-display {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 6px;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 14px;
            overflow-x: auto;
        }
        .auth-method {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            background: white;
        }
        .auth-title {
            font-weight: 600;
            color: #1976d2;
            margin-bottom: 10px;
        }
        .demo-controls {
            margin: 20px 0;
        }
        .demo-controls label {
            display: block;
            margin: 10px 0 5px;
            font-weight: 600;
        }
        .demo-controls input, .demo-controls select, .demo-controls textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .token-input {
            font-family: monospace;
            background: #f8f8f8;
            min-height: 80px;
            resize: vertical;
        }
        button {
            background: #1976d2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        button:hover {
            background: #1565c0;
        }
        .search-container {
            margin: 20px 0;
        }
        .search-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
        }
        .search-dropdown {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            max-height: 300px;
            overflow-y: auto;
            width: calc(100% - 2px);
            z-index: 1000;
            display: none;
        }
        .search-result {
            padding: 12px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }
        .search-result:hover {
            background: #f0f0f0;
        }
        .result-label {
            font-weight: 600;
            color: #333;
        }
        .result-meta {
            font-size: 14px;
            color: #666;
            margin-top: 4px;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            font-weight: 600;
        }
        .status.success {
            background: #e8f5e8;
            color: #2e7d32;
        }
        .status.error {
            background: #ffebee;
            color: #d32f2f;
        }
        .token-info {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
        }
        .request-log {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>Bearer Token Authentication Examples</h1>
    <p>Learn how to configure the Universal Search Component to work with APIs that use Bearer token authentication (JWT, OAuth access tokens, etc.).</p>

    <div class="security-warning">
        <strong>⚠️ Security Notice:</strong> Never store access tokens in localStorage or expose them in client-side code. This example is for demonstration. In production, use secure token storage and refresh mechanisms.
    </div>

    <div class="example-section">
        <h2>Bearer Token Methods</h2>
        
        <div class="auth-method">
            <div class="auth-title">1. JWT (JSON Web Token)</div>
            <p>Common for authenticated API access with expiration and refresh capabilities.</p>
            <div class="config-display">{
  dataSource: {
    type: 'api',
    api: {
      endpoint: 'https://api.example.com/search',
      method: 'GET',
      headers: {
        'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
        'Content-Type': 'application/json'
      },
      authentication: {
        type: 'bearer',
        credentials: {
          tokenProvider: async () => {
            return await getValidJWT(); // Refresh if expired
          }
        }
      }
    }
  }
}</div>
        </div>

        <div class="auth-method">
            <div class="auth-title">2. OAuth Access Token</div>
            <p>Standard OAuth 2.0 access token for third-party API integration.</p>
            <div class="config-display">{
  dataSource: {
    type: 'api',
    api: {
      endpoint: 'https://api.github.com/search/repositories',
      method: 'GET',
      headers: {
        'Authorization': 'Bearer ghp_xxxxxxxxxxxxxxxxxxxx',
        'Accept': 'application/vnd.github.v3+json'
      },
      authentication: {
        type: 'bearer',
        credentials: {
          token: 'ghp_xxxxxxxxxxxxxxxxxxxx',
          refreshEndpoint: '/auth/refresh'
        }
      }
    }
  }
}</div>
        </div>

        <div class="auth-method">
            <div class="auth-title">3. Custom Bearer Token</div>
            <p>Custom token format for proprietary APIs.</p>
            <div class="config-display">{
  dataSource: {
    type: 'api',
    api: {
      endpoint: 'https://api.example.com/search',
      method: 'POST',
      headers: {
        'Authorization': 'Bearer custom_token_format_here',
        'X-Client-Version': '1.0'
      },
      authentication: {
        type: 'bearer',
        credentials: {
          token: 'custom_token_format_here',
          scheme: 'Bearer'
        }
      }
    }
  }
}</div>
        </div>
    </div>

    <div class="example-section">
        <h2>Interactive Demo</h2>
        <div class="demo-controls">
            <label for="api-endpoint">API Endpoint:</label>
            <input type="url" id="api-endpoint" value="https://httpbin.org/bearer" placeholder="https://api.example.com/search">
            
            <label for="bearer-token">Bearer Token:</label>
            <textarea id="bearer-token" class="token-input" placeholder="Paste your JWT, OAuth token, or custom bearer token here">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</textarea>
            
            <label for="token-type">Token Type:</label>
            <select id="token-type">
                <option value="jwt">JWT (JSON Web Token)</option>
                <option value="oauth">OAuth Access Token</option>
                <option value="custom">Custom Token</option>
            </select>
            
            <button onclick="decodeToken()">Decode JWT</button>
            <button onclick="validateToken()">Validate Token</button>
            <button onclick="updateConfiguration()">Update Configuration</button>
            <button onclick="testAuthentication()">Test Authentication</button>
        </div>

        <div id="token-info" class="token-info" style="display: none;"></div>

        <div class="search-container">
            <div style="position: relative;">
                <input 
                    type="text" 
                    id="search-input" 
                    class="search-input" 
                    placeholder="Search with Bearer token... (try 'test')"
                    aria-label="Search with authentication"
                    autocomplete="off"
                >
                <div id="search-dropdown" class="search-dropdown" role="listbox" aria-label="Search results"></div>
            </div>
        </div>
        
        <div id="status" class="status" style="display: none;"></div>
    </div>

    <div class="example-section">
        <h2>Configuration</h2>
        <div class="config-display" id="config-display"></div>
    </div>

    <div class="example-section">
        <h2>Request Log</h2>
        <div id="request-log" class="request-log">No requests made yet...</div>
    </div>

    <div class="example-section">
        <h2>Token Management Best Practices</h2>
        <div class="config-display">// ✅ DO: Implement token refresh
class TokenManager {
  constructor() {
    this.token = null;
    this.refreshToken = null;
    this.expiresAt = null;
  }

  async getValidToken() {
    if (this.isTokenExpired()) {
      await this.refreshAccessToken();
    }
    return this.token;
  }

  isTokenExpired() {
    if (!this.expiresAt) return true;
    return Date.now() >= this.expiresAt - 60000; // Refresh 1min early
  }

  async refreshAccessToken() {
    try {
      const response = await fetch('/auth/refresh', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ refreshToken: this.refreshToken })
      });
      
      const data = await response.json();
      this.token = data.accessToken;
      this.expiresAt = Date.now() + (data.expiresIn * 1000);
    } catch (error) {
      // Handle refresh failure - redirect to login
      window.location.href = '/login';
    }
  }
}

// ✅ DO: Use secure token provider
const tokenManager = new TokenManager();

const searchConfig = {
  dataSource: {
    api: {
      authentication: {
        type: 'bearer',
        credentials: {
          tokenProvider: () => tokenManager.getValidToken()
        }
      },
      requestTransform: async (query) => {
        const token = await tokenManager.getValidToken();
        return {
          url: `${endpoint}?q=${query}`,
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        };
      }
    }
  }
};

// ❌ DON'T: Store tokens in localStorage
localStorage.setItem('token', 'sensitive-token'); // Vulnerable to XSS

// ❌ DON'T: Hardcode tokens
const hardcodedToken = 'sk-1234567890abcdef'; // Never do this!</div>
    </div>

    <script>
        let currentConfig = {
            dataSource: {
                type: 'api',
                api: {
                    endpoint: 'https://httpbin.org/bearer',
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    requestTransform: async (query) => {
                        const endpoint = document.getElementById('api-endpoint').value;
                        const token = document.getElementById('bearer-token').value.trim();
                        
                        const headers = { ...currentConfig.dataSource.api.headers };
                        
                        if (token) {
                            headers['Authorization'] = `Bearer ${token}`;
                        }
                        
                        // For httpbin demo, we'll use a simple GET
                        const url = endpoint.includes('httpbin.org') 
                            ? endpoint 
                            : `${endpoint}?q=${encodeURIComponent(query)}`;
                        
                        logRequest('GET', url, headers);
                        
                        return {
                            url,
                            method: 'GET',
                            headers
                        };
                    },
                    responseTransform: (data) => {
                        logResponse(data);
                        
                        // Handle httpbin.org response
                        if (data.authenticated !== undefined) {
                            return [{
                                label: `Authentication ${data.authenticated ? 'Successful' : 'Failed'}`,
                                value: 'auth-test',
                                metadata: {
                                    subtitle: data.token ? 'Token verified' : 'No token provided',
                                    category: 'Authentication',
                                    details: `Bearer token: ${data.token ? 'Present' : 'Missing'}`
                                }
                            }];
                        }
                        
                        // Handle standard API responses
                        const items = data.items || data.results || data.data || [];
                        if (!Array.isArray(items)) return [];
                        
                        return items.slice(0, 10).map(item => ({
                            label: item.name || item.title || 'No name',
                            value: item.id || Math.random(),
                            metadata: {
                                subtitle: item.description || 'No description',
                                category: item.type || 'Item',
                                details: JSON.stringify(item).substring(0, 100) + '...'
                            }
                        }));
                    }
                }
            },
            queryHandling: {
                minLength: 1,
                debounceMs: 500,
                triggerOn: 'change'
            },
            actionHandling: {
                onSelect: (result) => {
                    showStatus(`Selected: ${result.label}`, 'success');
                    hideDropdown();
                },
                onError: (error) => {
                    showStatus(`Error: ${error.message}`, 'error');
                },
                onLoading: (isLoading) => {
                    if (isLoading) {
                        showDropdown([{ type: 'loading', content: 'Authenticating and searching...' }]);
                    }
                }
            }
        };

        let debounceTimer;

        function displayConfig() {
            const configElement = document.getElementById('config-display');
            configElement.textContent = JSON.stringify(currentConfig, null, 2);
        }

        function logRequest(method, url, headers) {
            const log = document.getElementById('request-log');
            const timestamp = new Date().toLocaleTimeString();
            
            // Hide token in log for security
            const safeHeaders = { ...headers };
            if (safeHeaders['Authorization']) {
                const authHeader = safeHeaders['Authorization'];
                if (authHeader.startsWith('Bearer ')) {
                    const token = authHeader.substring(7);
                    safeHeaders['Authorization'] = `Bearer ${token.substring(0, 10)}...${token.substring(token.length - 10)}`;
                }
            }
            
            const logEntry = `[${timestamp}] ${method} ${url}\nHeaders: ${JSON.stringify(safeHeaders, null, 2)}\n\n`;
            log.textContent = logEntry + log.textContent;
        }

        function logResponse(data) {
            const log = document.getElementById('request-log');
            const timestamp = new Date().toLocaleTimeString();
            
            const responseInfo = {
                authenticated: data.authenticated,
                itemCount: data.items?.length || (Array.isArray(data) ? data.length : 0),
                totalCount: data.total_count || 'unknown'
            };
            
            const logEntry = `[${timestamp}] Response: ${JSON.stringify(responseInfo, null, 2)}\n\n`;
            log.textContent = log.textContent.replace(/(\[.*?\] GET[\s\S]*?)\n\n/, `$1\n${logEntry}`);
        }

        function decodeToken() {
            const token = document.getElementById('bearer-token').value.trim();
            const tokenInfo = document.getElementById('token-info');
            
            if (!token) {
                showStatus('Please enter a token first', 'error');
                return;
            }

            try {
                // Check if it's a JWT
                if (token.split('.').length === 3) {
                    const parts = token.split('.');
                    const header = JSON.parse(atob(parts[0]));
                    const payload = JSON.parse(atob(parts[1]));
                    
                    const info = `JWT Decoded:
Header: ${JSON.stringify(header, null, 2)}
Payload: ${JSON.stringify(payload, null, 2)}
Expires: ${payload.exp ? new Date(payload.exp * 1000).toLocaleString() : 'Not specified'}
Issued: ${payload.iat ? new Date(payload.iat * 1000).toLocaleString() : 'Not specified'}`;
                    
                    tokenInfo.textContent = info;
                    tokenInfo.style.display = 'block';
                    showStatus('JWT decoded successfully', 'success');
                } else {
                    tokenInfo.textContent = `Token Format: Custom/OAuth Access Token
Length: ${token.length} characters
Type: ${document.getElementById('token-type').value}
Note: Cannot decode non-JWT tokens`;
                    tokenInfo.style.display = 'block';
                    showStatus('Token information displayed', 'success');
                }
            } catch (error) {
                showStatus(`Failed to decode token: ${error.message}`, 'error');
                tokenInfo.style.display = 'none';
            }
        }

        function validateToken() {
            const token = document.getElementById('bearer-token').value.trim();
            
            if (!token) {
                showStatus('Please enter a token first', 'error');
                return;
            }

            // Basic validation
            const validations = [];
            
            if (token.length < 20) {
                validations.push('⚠️ Token seems too short');
            }
            
            if (token.split('.').length === 3) {
                validations.push('✅ Valid JWT format');
                
                try {
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    if (payload.exp && payload.exp * 1000 < Date.now()) {
                        validations.push('❌ JWT is expired');
                    } else if (payload.exp) {
                        validations.push('✅ JWT is not expired');
                    }
                } catch (e) {
                    validations.push('❌ Invalid JWT payload');
                }
            } else {
                validations.push('ℹ️ Not a JWT format');
            }
            
            if (token.startsWith('ghp_')) {
                validations.push('✅ GitHub personal access token format');
            }
            
            const result = validations.join('\n');
            showStatus(`Token validation:\n${result}`, validations.some(v => v.includes('❌')) ? 'error' : 'success');
        }

        async function performSearch(query) {
            if (query.length < currentConfig.queryHandling.minLength) {
                hideDropdown();
                return;
            }

            try {
                currentConfig.actionHandling.onLoading(true);
                
                const requestConfig = await currentConfig.dataSource.api.requestTransform(query);
                
                const response = await fetch(requestConfig.url, {
                    method: requestConfig.method,
                    headers: requestConfig.headers
                });

                if (!response.ok) {
                    if (response.status === 401) {
                        throw new Error('Authentication failed - invalid or expired token');
                    } else if (response.status === 403) {
                        throw new Error('Access forbidden - insufficient token permissions');
                    } else if (response.status === 429) {
                        throw new Error('Rate limit exceeded');
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                }

                const data = await response.json();
                const transformedResults = currentConfig.dataSource.api.responseTransform(data);
                
                if (transformedResults.length === 0) {
                    showDropdown([{ type: 'message', content: 'No results found' }]);
                } else {
                    showDropdown(transformedResults);
                }

            } catch (error) {
                console.error('Search error:', error);
                currentConfig.actionHandling.onError(error);
                hideDropdown();
            }
        }

        function showDropdown(results) {
            const dropdown = document.getElementById('search-dropdown');
            dropdown.innerHTML = '';

            results.forEach((result, index) => {
                const resultElement = document.createElement('div');
                
                if (result.type === 'loading') {
                    resultElement.className = 'loading';
                    resultElement.textContent = result.content;
                    resultElement.style.padding = '12px';
                    resultElement.style.textAlign = 'center';
                    resultElement.style.color = '#666';
                } else if (result.type === 'message') {
                    resultElement.className = 'loading';
                    resultElement.textContent = result.content;
                    resultElement.style.padding = '12px';
                    resultElement.style.textAlign = 'center';
                    resultElement.style.color = '#666';
                } else {
                    resultElement.className = 'search-result';
                    resultElement.innerHTML = `
                        <div class="result-label">${escapeHtml(result.label)}</div>
                        <div class="result-meta">${escapeHtml(result.metadata?.subtitle || '')}</div>
                        <div class="result-meta">${escapeHtml(result.metadata?.details || '')}</div>
                    `;
                    
                    resultElement.addEventListener('click', () => {
                        currentConfig.actionHandling.onSelect(result);
                    });
                }
                
                dropdown.appendChild(resultElement);
            });

            dropdown.style.display = 'block';
        }

        function hideDropdown() {
            document.getElementById('search-dropdown').style.display = 'none';
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 5000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function updateConfiguration() {
            displayConfig();
            showStatus('Configuration updated successfully', 'success');
        }

        async function testAuthentication() {
            const endpoint = document.getElementById('api-endpoint').value;
            const token = document.getElementById('bearer-token').value.trim();
            
            if (!token) {
                showStatus('Please enter a Bearer token first', 'error');
                return;
            }
            
            try {
                showStatus('Testing Bearer token authentication...', 'success');
                
                const headers = {
                    'Authorization': `Bearer ${token}`,
                    'Accept': 'application/json'
                };
                
                const response = await fetch(endpoint, { headers });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.authenticated === true) {
                        showStatus('Bearer token authentication successful', 'success');
                    } else if (data.authenticated === false) {
                        showStatus('Bearer token authentication failed - invalid token', 'error');
                    } else {
                        showStatus(`Authentication test completed (${response.status})`, 'success');
                    }
                } else if (response.status === 401) {
                    showStatus('Authentication failed - invalid or expired token', 'error');
                } else if (response.status === 403) {
                    showStatus('Access forbidden - check token permissions', 'error');
                } else {
                    showStatus(`Test returned ${response.status}: ${response.statusText}`, 'error');
                }
                
            } catch (error) {
                showStatus(`Authentication test failed: ${error.message}`, 'error');
            }
        }

        // Event listeners
        document.getElementById('search-input').addEventListener('input', (e) => {
            const query = e.target.value.trim();
            
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                performSearch(query);
            }, currentConfig.queryHandling.debounceMs);
        });

        document.getElementById('search-input').addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                hideDropdown();
            }
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) {
                hideDropdown();
            }
        });

        // Initialize
        displayConfig();
    </script>
</body>
</html>