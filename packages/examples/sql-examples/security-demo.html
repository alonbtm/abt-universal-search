<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Security Demonstration - Universal Search Component</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #7f8c8d;
            font-size: 16px;
        }
        .section {
            background: white;
            margin-bottom: 30px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .section-header {
            background: #e74c3c;
            color: white;
            padding: 15px 20px;
            font-weight: 600;
        }
        .section-content {
            padding: 20px;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
            margin: 10px 0;
        }
        .danger {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
        }
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
        }
        .info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
        }
        .tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 600;
            color: #6c757d;
        }
        .tab.active {
            color: #e74c3c;
            border-bottom-color: #e74c3c;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .attack-simulator {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .attack-panel {
            border: 2px solid #dc3545;
            border-radius: 8px;
            padding: 20px;
            background: #fff5f5;
        }
        .defense-panel {
            border: 2px solid #28a745;
            border-radius: 8px;
            padding: 20px;
            background: #f8fff8;
        }
        .demo-controls {
            margin-bottom: 15px;
        }
        .form-group {
            margin-bottom: 10px;
        }
        label {
            font-weight: 600;
            margin-bottom: 5px;
            display: block;
            color: #495057;
        }
        input, select, textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-top: 10px;
        }
        button:hover {
            background: #c0392b;
        }
        .safe-button {
            background: #28a745;
        }
        .safe-button:hover {
            background: #218838;
        }
        .query-output {
            background: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            margin-top: 15px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .vulnerability-list {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
        }
        .vulnerability-list ul {
            list-style-type: none;
            padding-left: 0;
        }
        .vulnerability-list li {
            padding: 5px 0;
            position: relative;
            padding-left: 25px;
        }
        .vulnerability-list li:before {
            content: '‚ö†Ô∏è';
            position: absolute;
            left: 0;
        }
        .security-checklist {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
        }
        .security-checklist ul {
            list-style-type: none;
            padding-left: 0;
        }
        .security-checklist li {
            padding: 5px 0;
            position: relative;
            padding-left: 25px;
        }
        .security-checklist li:before {
            content: '‚úÖ';
            position: absolute;
            left: 0;
        }
        .attack-vector {
            background: #ffe6e6;
            border: 1px solid #ffb3b3;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .defense-strategy {
            background: #e6ffe6;
            border: 1px solid #b3ffb3;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .vulnerable-code {
            background: #fff5f5;
            border-left: 4px solid #dc3545;
            padding: 15px;
        }
        .secure-code {
            background: #f0fff4;
            border-left: 4px solid #28a745;
            padding: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>SQL Security Demonstration</h1>
            <div class="subtitle">Comprehensive security showcase with injection prevention and input sanitization</div>
        </div>

        <!-- Security Overview -->
        <div class="section">
            <div class="section-header">SQL Security Threats & Defenses</div>
            <div class="section-content">
                <div class="danger">
                    <h4>üö® Critical SQL Security Vulnerabilities</h4>
                    <p>SQL injection remains one of the most dangerous and prevalent web application vulnerabilities. Understanding these threats is essential for secure application development.</p>
                </div>

                <div class="vulnerability-list">
                    <h4>Common SQL Security Vulnerabilities:</h4>
                    <ul>
                        <li><strong>SQL Injection:</strong> Malicious SQL code injected through user inputs</li>
                        <li><strong>Blind SQL Injection:</strong> Information extraction without direct error messages</li>
                        <li><strong>Time-based Attacks:</strong> Using database delays to extract information</li>
                        <li><strong>Union-based Attacks:</strong> Combining results from multiple queries</li>
                        <li><strong>Second-order Injection:</strong> Stored malicious input executed later</li>
                        <li><strong>NoSQL Injection:</strong> Similar attacks on NoSQL databases</li>
                        <li><strong>ORM Injection:</strong> Vulnerabilities in Object-Relational Mapping layers</li>
                        <li><strong>Privilege Escalation:</strong> Unauthorized access to admin functions</li>
                    </ul>
                </div>

                <div class="security-checklist">
                    <h4>Defense Strategies:</h4>
                    <ul>
                        <li><strong>Parameterized Queries:</strong> Always use prepared statements</li>
                        <li><strong>Input Validation:</strong> Validate and sanitize all user inputs</li>
                        <li><strong>Least Privilege:</strong> Use minimal database permissions</li>
                        <li><strong>Output Encoding:</strong> Properly encode data before display</li>
                        <li><strong>WAF Protection:</strong> Web Application Firewall filtering</li>
                        <li><strong>Regular Security Testing:</strong> Automated and manual security scans</li>
                        <li><strong>Database Monitoring:</strong> Log and monitor suspicious activities</li>
                        <li><strong>Connection Security:</strong> Encrypted connections and secure configurations</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Attack Simulation -->
        <div class="section">
            <div class="section-header">Interactive SQL Injection Simulator</div>
            <div class="section-content">
                <div class="info">
                    <strong>Educational Purpose:</strong> This simulator demonstrates how SQL injection attacks work and how proper defenses prevent them. All attacks are simulated and safe.
                </div>

                <div class="attack-simulator">
                    <div class="attack-panel">
                        <h4>üî¥ Attack Vector Simulator</h4>
                        <div class="demo-controls">
                            <div class="form-group">
                                <label for="attack-type">Attack Type:</label>
                                <select id="attack-type" onchange="updateAttackExample()">
                                    <option value="classic">Classic SQL Injection</option>
                                    <option value="union">Union-based Attack</option>
                                    <option value="blind">Blind SQL Injection</option>
                                    <option value="time">Time-based Attack</option>
                                    <option value="second-order">Second-order Injection</option>
                                    <option value="privilege">Privilege Escalation</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="attack-payload">Malicious Payload:</label>
                                <textarea id="attack-payload" rows="3" placeholder="Enter attack payload..."></textarea>
                            </div>
                            
                            <div class="form-group">
                                <label for="target-field">Target Field:</label>
                                <select id="target-field">
                                    <option value="username">Username</option>
                                    <option value="search">Search Query</option>
                                    <option value="id">User ID</option>
                                    <option value="category">Category</option>
                                </select>
                            </div>
                        </div>
                        
                        <button onclick="simulateAttack()">Simulate Attack</button>
                        
                        <div id="attack-results" class="query-output"></div>
                    </div>
                    
                    <div class="defense-panel">
                        <h4>üü¢ Defense Demonstration</h4>
                        <div class="demo-controls">
                            <div class="form-group">
                                <label for="defense-method">Defense Method:</label>
                                <select id="defense-method">
                                    <option value="parameterized">Parameterized Queries</option>
                                    <option value="validation">Input Validation</option>
                                    <option value="sanitization">Data Sanitization</option>
                                    <option value="whitelist">Whitelist Filtering</option>
                                    <option value="escaping">Proper Escaping</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="database-type">Database Type:</label>
                                <select id="database-type">
                                    <option value="postgresql">PostgreSQL</option>
                                    <option value="mysql">MySQL</option>
                                    <option value="sqlite">SQLite</option>
                                </select>
                            </div>
                        </div>
                        
                        <button class="safe-button" onclick="demonstrateDefense()">Show Defense</button>
                        
                        <div id="defense-results" class="query-output"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Attack Vectors Deep Dive -->
        <div class="section">
            <div class="section-header">SQL Injection Attack Vectors</div>
            <div class="section-content">
                <div class="tabs">
                    <div class="tab active" onclick="showTab('classic-injection')">Classic Injection</div>
                    <div class="tab" onclick="showTab('union-attacks')">Union Attacks</div>
                    <div class="tab" onclick="showTab('blind-injection')">Blind Injection</div>
                    <div class="tab" onclick="showTab('advanced-attacks')">Advanced Attacks</div>
                </div>

                <div id="classic-injection" class="tab-content active">
                    <h3>Classic SQL Injection</h3>
                    
                    <div class="attack-vector">
                        <h4>‚ùå Vulnerable Code Pattern</h4>
                        <div class="code-block">
// DANGEROUS: Direct string concatenation
const getUserByName = (username) => {
    const query = `SELECT * FROM users WHERE username = '${username}'`;
    return database.query(query);
};

// User input: "admin' OR '1'='1' --"
// Resulting query: SELECT * FROM users WHERE username = 'admin' OR '1'='1' --'
// Effect: Returns ALL users, bypassing authentication

// Another dangerous pattern
const searchProducts = (searchTerm, category) => {
    const sql = `
        SELECT id, name, price FROM products 
        WHERE name LIKE '%${searchTerm}%' 
        AND category = '${category}'
    `;
    return db.query(sql);
};

// Malicious input: searchTerm = "'; DROP TABLE products; --"
// Resulting query executes: DROP TABLE products
                        </div>
                    </div>

                    <div class="defense-strategy">
                        <h4>‚úÖ Secure Implementation</h4>
                        <div class="code-block">
// SAFE: Parameterized queries
const getUserByName = async (username) => {
    const query = 'SELECT * FROM users WHERE username = ?';
    return await database.query(query, [username]);
};

// PostgreSQL version
const getUserByNamePG = async (username) => {
    const query = 'SELECT * FROM users WHERE username = $1';
    return await pgClient.query(query, [username]);
};

// Safe search with multiple parameters
const searchProducts = async (searchTerm, category) => {
    const query = `
        SELECT id, name, price FROM products 
        WHERE name ILIKE $1 
        AND category = $2
    `;
    return await pgClient.query(query, [`%${searchTerm}%`, category]);
};

// Input validation layer
const validateAndSearch = async (searchTerm, category) => {
    // Validate inputs
    if (!searchTerm || searchTerm.length > 100) {
        throw new Error('Invalid search term');
    }
    
    const allowedCategories = ['electronics', 'books', 'clothing', 'sports'];
    if (!allowedCategories.includes(category.toLowerCase())) {
        throw new Error('Invalid category');
    }
    
    // Execute safe search
    return await searchProducts(searchTerm, category);
};
                        </div>
                    </div>

                    <div class="comparison-grid">
                        <div class="vulnerable-code">
                            <h4>Vulnerable Query Examples</h4>
                            <div class="code-block">
-- Original intended query
SELECT * FROM users WHERE id = 1

-- After injection: id = "1; DROP TABLE users; --"
SELECT * FROM users WHERE id = 1; DROP TABLE users; --

-- Login bypass: username = "admin' --"
SELECT * FROM users WHERE username = 'admin' --' AND password = 'any'

-- Always true condition: "' OR '1'='1"
SELECT * FROM products WHERE name = '' OR '1'='1'
                            </div>
                        </div>
                        
                        <div class="secure-code">
                            <h4>Parameterized Query Protection</h4>
                            <div class="code-block">
-- Parameterized query (safe)
SELECT * FROM users WHERE id = ?
-- Parameters: [1]

-- Malicious input treated as literal string
-- Parameters: ["1; DROP TABLE users; --"]
-- Result: No user found with that exact ID

-- Login attempt with parameterized query
SELECT * FROM users WHERE username = ? AND password = ?
-- Parameters: ["admin", "anypassword"]
-- Result: Only checks exact username/password match
                            </div>
                        </div>
                    </div>
                </div>

                <div id="union-attacks" class="tab-content">
                    <h3>Union-based SQL Injection</h3>
                    
                    <div class="attack-vector">
                        <h4>‚ùå Union Attack Scenario</h4>
                        <div class="code-block">
// Vulnerable search endpoint
app.get('/search', (req, res) => {
    const searchTerm = req.query.q;
    const query = `SELECT id, title, content FROM articles WHERE title LIKE '%${searchTerm}%'`;
    
    db.query(query, (err, results) => {
        res.json(results);
    });
});

// Attacker payload: "' UNION SELECT id, username, password FROM users --"
// Resulting query:
SELECT id, title, content FROM articles WHERE title LIKE '%' UNION SELECT id, username, password FROM users --%'

// Effect: Exposes all usernames and passwords from users table
                        </div>
                    </div>

                    <div class="defense-strategy">
                        <h4>‚úÖ Protected Implementation</h4>
                        <div class="code-block">
// Safe search with parameterized queries
app.get('/search', async (req, res) => {
    try {
        const searchTerm = req.query.q;
        
        // Input validation
        if (!searchTerm || typeof searchTerm !== 'string' || searchTerm.length > 100) {
            return res.status(400).json({ error: 'Invalid search term' });
        }
        
        // Parameterized query prevents UNION attacks
        const query = `
            SELECT id, title, LEFT(content, 200) as content_preview 
            FROM articles 
            WHERE title ILIKE $1 
            AND status = 'published'
            ORDER BY created_at DESC 
            LIMIT 20
        `;
        
        const results = await pgClient.query(query, [`%${searchTerm}%`]);
        
        // Additional security: only return expected fields
        const sanitizedResults = results.rows.map(row => ({
            id: row.id,
            title: row.title,
            content_preview: row.content_preview
        }));
        
        res.json(sanitizedResults);
        
    } catch (error) {
        console.error('Search error:', error);
        res.status(500).json({ error: 'Search failed' });
    }
});

// Advanced protection with query result validation
const validateQueryResults = (results, expectedFields) => {
    return results.filter(row => {
        // Ensure only expected fields are present
        const allowedKeys = Object.keys(row).filter(key => expectedFields.includes(key));
        const cleanRow = {};
        allowedKeys.forEach(key => {
            cleanRow[key] = row[key];
        });
        return cleanRow;
    });
};
                        </div>
                    </div>

                    <div class="warning">
                        <h4>Union Attack Detection</h4>
                        <p>Signs of Union-based attacks:</p>
                        <ul>
                            <li>Unexpected number of columns in results</li>
                            <li>Data from unintended tables</li>
                            <li>SQL keywords like UNION, SELECT in user input</li>
                            <li>Error messages revealing database structure</li>
                        </ul>
                    </div>
                </div>

                <div id="blind-injection" class="tab-content">
                    <h3>Blind SQL Injection</h3>
                    
                    <div class="attack-vector">
                        <h4>‚ùå Blind Injection Scenario</h4>
                        <div class="code-block">
// Vulnerable login that doesn't return detailed errors
app.post('/login', (req, res) => {
    const { username, password } = req.body;
    
    const query = `SELECT id FROM users WHERE username = '${username}' AND password = '${password}'`;
    
    db.query(query, (err, results) => {
        if (err) {
            // Generic error message (good)
            return res.json({ success: false, message: 'Login failed' });
        }
        
        if (results.length > 0) {
            res.json({ success: true, message: 'Login successful' });
        } else {
            res.json({ success: false, message: 'Login failed' });
        }
    });
});

// Blind injection payload: username = "admin' AND (SELECT COUNT(*) FROM users) > 0 AND '1'='1"
// If users table exists, login attempt will behave differently
// Attacker can extract information bit by bit:

// Check if database is MySQL:
// username = "admin' AND (SELECT @@version LIKE 'MySQL%') AND '1'='1"

// Extract database name length:
// username = "admin' AND (SELECT LENGTH(DATABASE())) = 10 AND '1'='1"

// Extract first character of database name:
// username = "admin' AND (SELECT ASCII(SUBSTRING(DATABASE(),1,1))) = 115 AND '1'='1"
                        </div>
                    </div>

                    <div class="defense-strategy">
                        <h4>‚úÖ Blind Injection Prevention</h4>
                        <div class="code-block">
const bcrypt = require('bcrypt');
const rateLimit = require('express-rate-limit');

// Rate limiting for login attempts
const loginLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // limit each IP to 5 requests per windowMs
    message: 'Too many login attempts, please try again later'
});

app.post('/login', loginLimiter, async (req, res) => {
    try {
        const { username, password } = req.body;
        
        // Input validation
        if (!username || !password || typeof username !== 'string' || typeof password !== 'string') {
            return res.status(400).json({ 
                success: false, 
                message: 'Invalid credentials' 
            });
        }
        
        if (username.length > 50 || password.length > 100) {
            return res.status(400).json({ 
                success: false, 
                message: 'Invalid credentials' 
            });
        }
        
        // Parameterized query
        const query = 'SELECT id, password_hash FROM users WHERE username = $1 AND active = true';
        const result = await pgClient.query(query, [username]);
        
        // Timing attack prevention: always perform hash comparison
        const user = result.rows[0];
        const providedPasswordHash = user ? user.password_hash : '$2b$10$dummy.hash.to.prevent.timing.attack';
        
        const isValidPassword = await bcrypt.compare(password, providedPasswordHash);
        
        if (user && isValidPassword) {
            // Successful login
            const token = generateJWT({ userId: user.id, username });
            res.json({ 
                success: true, 
                token,
                message: 'Login successful' 
            });
        } else {
            // Always same response for failed login
            await new Promise(resolve => setTimeout(resolve, Math.random() * 100)); // Random delay
            res.status(401).json({ 
                success: false, 
                message: 'Invalid credentials' 
            });
        }
        
        // Log failed attempts for monitoring
        if (!user || !isValidPassword) {
            console.warn(`Failed login attempt for username: ${username} from IP: ${req.ip}`);
        }
        
    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Login failed' 
        });
    }
});

// Additional monitoring and alerting
const monitorSuspiciousQueries = (query, params) => {
    const suspiciousPatterns = [
        /union\s+select/i,
        /or\s+1\s*=\s*1/i,
        /and\s+1\s*=\s*1/i,
        /sleep\s*\(/i,
        /waitfor\s+delay/i,
        /benchmark\s*\(/i
    ];
    
    const queryString = query + ' ' + JSON.stringify(params);
    const isSuspicious = suspiciousPatterns.some(pattern => pattern.test(queryString));
    
    if (isSuspicious) {
        console.alert('SECURITY ALERT: Suspicious query detected', {
            query,
            params,
            timestamp: new Date().toISOString()
        });
    }
    
    return isSuspicious;
};
                        </div>
                    </div>

                    <div class="info">
                        <h4>Blind Injection Prevention Strategies:</h4>
                        <ul>
                            <li><strong>Consistent Response Times:</strong> Prevent timing-based attacks</li>
                            <li><strong>Generic Error Messages:</strong> Don't reveal database structure</li>
                            <li><strong>Rate Limiting:</strong> Slow down automated attacks</li>
                            <li><strong>Query Monitoring:</strong> Detect suspicious patterns</li>
                            <li><strong>Input Length Limits:</strong> Prevent complex injection payloads</li>
                        </ul>
                    </div>
                </div>

                <div id="advanced-attacks" class="tab-content">
                    <h3>Advanced SQL Injection Techniques</h3>
                    
                    <div class="attack-vector">
                        <h4>‚ùå Second-Order SQL Injection</h4>
                        <div class="code-block">
// Vulnerable user registration (stores malicious data)
app.post('/register', (req, res) => {
    const { username, email, bio } = req.body;
    
    // This query is properly parameterized (safe for now)
    const insertQuery = 'INSERT INTO users (username, email, bio) VALUES (?, ?, ?)';
    db.query(insertQuery, [username, email, bio]);
});

// Vulnerable profile display (executes stored malicious data)
app.get('/profile/:id', (req, res) => {
    const userId = req.params.id;
    
    // First query: safe parameterized query
    const getUserQuery = 'SELECT username, email, bio FROM users WHERE id = ?';
    db.query(getUserQuery, [userId], (err, results) => {
        const user = results[0];
        
        // DANGEROUS: Using stored data in new query without parameterization
        const getPostsQuery = `SELECT * FROM posts WHERE author = '${user.username}'`;
        db.query(getPostsQuery, (err, posts) => {
            res.json({ user, posts });
        });
    });
});

// Attack scenario:
// 1. Attacker registers with username: "admin'; DROP TABLE posts; --"
// 2. Data is stored safely in database
// 3. When profile is viewed, getPostsQuery becomes:
//    "SELECT * FROM posts WHERE author = 'admin'; DROP TABLE posts; --'"
// 4. Posts table is dropped!
                        </div>
                    </div>

                    <div class="defense-strategy">
                        <h4>‚úÖ Second-Order Injection Prevention</h4>
                        <div class="code-block">
// Safe implementation: Always parameterize, even with stored data
app.get('/profile/:id', async (req, res) => {
    try {
        const userId = parseInt(req.params.id);
        
        if (!userId || userId <= 0) {
            return res.status(400).json({ error: 'Invalid user ID' });
        }
        
        // Get user data with parameterized query
        const getUserQuery = 'SELECT id, username, email, bio FROM users WHERE id = $1';
        const userResult = await pgClient.query(getUserQuery, [userId]);
        
        if (userResult.rows.length === 0) {
            return res.status(404).json({ error: 'User not found' });
        }
        
        const user = userResult.rows[0];
        
        // IMPORTANT: Still use parameterized query with stored data
        const getPostsQuery = `
            SELECT id, title, content, created_at 
            FROM posts 
            WHERE author_id = $1 
            AND status = 'published'
            ORDER BY created_at DESC
        `;
        
        const postsResult = await pgClient.query(getPostsQuery, [user.id]);
        
        res.json({
            user: {
                id: user.id,
                username: user.username,
                email: user.email,
                bio: user.bio
            },
            posts: postsResult.rows
        });
        
    } catch (error) {
        console.error('Profile fetch error:', error);
        res.status(500).json({ error: 'Failed to fetch profile' });
    }
});

// Additional security: Data sanitization on input
const sanitizeInput = (input, maxLength = 255) => {
    if (typeof input !== 'string') return '';
    
    // Remove potential SQL keywords and special characters
    let sanitized = input
        .replace(/['"`;\\]/g, '') // Remove dangerous characters
        .replace(/\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|OR|AND)\b/gi, '') // Remove SQL keywords
        .trim()
        .substring(0, maxLength);
    
    return sanitized;
};

app.post('/register', async (req, res) => {
    try {
        const { username, email, bio } = req.body;
        
        // Validate and sanitize inputs
        const cleanUsername = sanitizeInput(username, 50);
        const cleanEmail = sanitizeInput(email, 100);
        const cleanBio = sanitizeInput(bio, 500);
        
        // Additional validation
        if (cleanUsername.length < 3) {
            return res.status(400).json({ error: 'Username too short' });
        }
        
        if (!cleanEmail.includes('@')) {
            return res.status(400).json({ error: 'Invalid email' });
        }
        
        // Check for existing user
        const checkQuery = 'SELECT id FROM users WHERE username = $1 OR email = $2';
        const existing = await pgClient.query(checkQuery, [cleanUsername, cleanEmail]);
        
        if (existing.rows.length > 0) {
            return res.status(409).json({ error: 'User already exists' });
        }
        
        // Insert with parameterized query
        const insertQuery = `
            INSERT INTO users (username, email, bio, created_at) 
            VALUES ($1, $2, $3, NOW()) 
            RETURNING id, username, email
        `;
        
        const result = await pgClient.query(insertQuery, [cleanUsername, cleanEmail, cleanBio]);
        
        res.status(201).json({
            success: true,
            user: result.rows[0]
        });
        
    } catch (error) {
        console.error('Registration error:', error);
        res.status(500).json({ error: 'Registration failed' });
    }
});
                        </div>
                    </div>

                    <div class="warning">
                        <h4>ORM Injection Vulnerabilities</h4>
                        <div class="code-block">
// Vulnerable ORM usage
app.get('/users/search', (req, res) => {
    const { query } = req.query;
    
    // DANGEROUS: Dynamic query building
    User.find({
        $where: `this.name.indexOf('${query}') !== -1`
    }).then(users => {
        res.json(users);
    });
});

// Safe ORM usage
app.get('/users/search', async (req, res) => {
    try {
        const { query } = req.query;
        
        // Input validation
        if (!query || typeof query !== 'string' || query.length > 50) {
            return res.status(400).json({ error: 'Invalid search query' });
        }
        
        // Safe query with proper ORM methods
        const users = await User.find({
            name: { $regex: new RegExp(query, 'i') }
        }).select('id name email').limit(20);
        
        res.json(users);
        
    } catch (error) {
        console.error('Search error:', error);
        res.status(500).json({ error: 'Search failed' });
    }
});
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Security Best Practices -->
        <div class="section">
            <div class="section-header">Comprehensive Security Implementation</div>
            <div class="section-content">
                <div class="tabs">
                    <div class="tab active" onclick="showSecurityTab('input-validation')">Input Validation</div>
                    <div class="tab" onclick="showSecurityTab('output-encoding')">Output Encoding</div>
                    <div class="tab" onclick="showSecurityTab('database-security')">Database Security</div>
                    <div class="tab" onclick="showSecurityTab('monitoring')">Monitoring & Logging</div>
                </div>

                <div id="input-validation" class="tab-content active">
                    <h3>Comprehensive Input Validation</h3>
                    <div class="code-block">
const validator = require('validator');
const DOMPurify = require('dompurify');

// Multi-layered input validation system
class InputValidator {
    static validateSearchTerm(searchTerm) {
        const errors = [];
        
        // Basic type and presence check
        if (!searchTerm || typeof searchTerm !== 'string') {
            errors.push('Search term must be a non-empty string');
        }
        
        // Length validation
        if (searchTerm.length > 100) {
            errors.push('Search term too long (max 100 characters)');
        }
        
        if (searchTerm.length < 2) {
            errors.push('Search term too short (min 2 characters)');
        }
        
        // Character whitelist
        const allowedPattern = /^[a-zA-Z0-9\s\-_.,']+$/;
        if (!allowedPattern.test(searchTerm)) {
            errors.push('Search term contains invalid characters');
        }
        
        // SQL injection pattern detection
        const sqlPatterns = [
            /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|ALTER|CREATE|EXEC)\b)/i,
            /(--|\/\*|\*\/|;|\bOR\b|\bAND\b)/i,
            /(['"`;\\])/,
            /(\bxp_\b|\bsp_\b)/i  // SQL Server extended procedures
        ];
        
        sqlPatterns.forEach(pattern => {
            if (pattern.test(searchTerm)) {
                errors.push('Invalid characters or SQL keywords detected');
            }
        });
        
        return {
            isValid: errors.length === 0,
            errors,
            sanitized: this.sanitizeSearchTerm(searchTerm)
        };
    }
    
    static sanitizeSearchTerm(searchTerm) {
        if (!searchTerm) return '';
        
        // Remove HTML tags
        let sanitized = DOMPurify.sanitize(searchTerm, { ALLOWED_TAGS: [] });
        
        // Remove potential SQL injection characters
        sanitized = sanitized
            .replace(/['"`;\\]/g, '') // Remove quotes and dangerous chars
            .replace(/\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|ALTER|CREATE|EXEC|OR|AND)\b/gi, '') // Remove SQL keywords
            .replace(/--.*$/g, '') // Remove SQL comments
            .replace(/\/\*.*\*\//g, '') // Remove block comments
            .trim();
        
        return sanitized.substring(0, 100); // Limit length
    }
    
    static validateCategory(category) {
        const allowedCategories = [
            'technology', 'science', 'health', 'business', 
            'entertainment', 'sports', 'politics', 'education'
        ];
        
        if (!category || typeof category !== 'string') {
            return { isValid: false, error: 'Category must be a string' };
        }
        
        const normalized = category.toLowerCase().trim();
        
        if (!allowedCategories.includes(normalized)) {
            return { 
                isValid: false, 
                error: `Invalid category. Allowed: ${allowedCategories.join(', ')}` 
            };
        }
        
        return { isValid: true, normalized };
    }
    
    static validateNumericRange(value, min, max, fieldName) {
        if (value === null || value === undefined) {
            return { isValid: true, normalized: null };
        }
        
        const num = parseFloat(value);
        
        if (isNaN(num)) {
            return { isValid: false, error: `${fieldName} must be a number` };
        }
        
        if (min !== undefined && num < min) {
            return { isValid: false, error: `${fieldName} must be at least ${min}` };
        }
        
        if (max !== undefined && num > max) {
            return { isValid: false, error: `${fieldName} must be at most ${max}` };
        }
        
        return { isValid: true, normalized: num };
    }
    
    static validateDateRange(dateStr, fieldName) {
        if (!dateStr) return { isValid: true, normalized: null };
        
        if (!validator.isISO8601(dateStr)) {
            return { isValid: false, error: `${fieldName} must be a valid ISO 8601 date` };
        }
        
        const date = new Date(dateStr);
        const now = new Date();
        const oneYearAgo = new Date(now.getFullYear() - 1, now.getMonth(), now.getDate());
        const oneYearFromNow = new Date(now.getFullYear() + 1, now.getMonth(), now.getDate());
        
        if (date < oneYearAgo || date > oneYearFromNow) {
            return { isValid: false, error: `${fieldName} must be within the last year or next year` };
        }
        
        return { isValid: true, normalized: date.toISOString() };
    }
}

// Usage in API endpoint
app.get('/api/search', async (req, res) => {
    try {
        const { q: searchTerm, category, minPrice, maxPrice, dateFrom, dateTo } = req.query;
        
        // Validate search term
        const searchValidation = InputValidator.validateSearchTerm(searchTerm);
        if (!searchValidation.isValid) {
            return res.status(400).json({ 
                error: 'Invalid search term', 
                details: searchValidation.errors 
            });
        }
        
        // Validate category
        const categoryValidation = InputValidator.validateCategory(category);
        if (!categoryValidation.isValid) {
            return res.status(400).json({ 
                error: categoryValidation.error 
            });
        }
        
        // Validate price range
        const minPriceValidation = InputValidator.validateNumericRange(minPrice, 0, 10000, 'Minimum price');
        const maxPriceValidation = InputValidator.validateNumericRange(maxPrice, 0, 10000, 'Maximum price');
        
        if (!minPriceValidation.isValid || !maxPriceValidation.isValid) {
            return res.status(400).json({ 
                error: 'Invalid price range',
                details: [minPriceValidation.error, maxPriceValidation.error].filter(Boolean)
            });
        }
        
        // Validate date range
        const dateFromValidation = InputValidator.validateDateRange(dateFrom, 'Date from');
        const dateToValidation = InputValidator.validateDateRange(dateTo, 'Date to');
        
        if (!dateFromValidation.isValid || !dateToValidation.isValid) {
            return res.status(400).json({ 
                error: 'Invalid date range',
                details: [dateFromValidation.error, dateToValidation.error].filter(Boolean)
            });
        }
        
        // Execute safe search with validated and sanitized inputs
        const searchResults = await executeSecureSearch({
            searchTerm: searchValidation.sanitized,
            category: categoryValidation.normalized,
            minPrice: minPriceValidation.normalized,
            maxPrice: maxPriceValidation.normalized,
            dateFrom: dateFromValidation.normalized,
            dateTo: dateToValidation.normalized
        });
        
        res.json(searchResults);
        
    } catch (error) {
        console.error('Search API error:', error);
        res.status(500).json({ error: 'Search failed' });
    }
});
                    </div>
                </div>

                <div id="output-encoding" class="tab-content">
                    <h3>Output Encoding and Data Sanitization</h3>
                    <div class="code-block">
const DOMPurify = require('dompurify');
const { JSDOM } = require('jsdom');

// Server-side DOMPurify setup
const window = new JSDOM('').window;
const purify = DOMPurify(window);

class OutputEncoder {
    // HTML encoding for safe display
    static encodeHTML(str) {
        if (!str) return '';
        
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;')
            .replace(/\//g, '&#x2F;');
    }
    
    // JavaScript string encoding
    static encodeJavaScript(str) {
        if (!str) return '';
        
        return str
            .replace(/\\/g, '\\\\')
            .replace(/'/g, "\\'")
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t')
            .replace(/\f/g, '\\f')
            .replace(/\v/g, '\\v');
    }
    
    // URL encoding
    static encodeURL(str) {
        if (!str) return '';
        return encodeURIComponent(str);
    }
    
    // CSS encoding
    static encodeCSS(str) {
        if (!str) return '';
        
        return str.replace(/[^a-zA-Z0-9]/g, (match) => {
            const hex = match.charCodeAt(0).toString(16).padStart(6, '0');
            return `\\${hex} `;
        });
    }
    
    // Sanitize rich text content
    static sanitizeHTML(html) {
        if (!html) return '';
        
        const cleanHTML = purify.sanitize(html, {
            ALLOWED_TAGS: ['b', 'i', 'u', 'strong', 'em', 'p', 'br', 'ul', 'ol', 'li', 'a'],
            ALLOWED_ATTR: ['href'],
            ALLOW_DATA_ATTR: false,
            FORBID_SCRIPT: true,
            FORBID_TAGS: ['script', 'object', 'embed', 'iframe', 'form'],
            FORBID_ATTR: ['onload', 'onerror', 'onclick', 'onmouseover']
        });
        
        return cleanHTML;
    }
    
    // JSON-safe encoding
    static encodeJSON(obj) {
        return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'string') {
                return this.encodeHTML(value);
            }
            return value;
        });
    }
    
    // Database output sanitization
    static sanitizeSearchResults(results) {
        return results.map(result => ({
            id: result.id,
            title: this.encodeHTML(result.title),
            content: this.sanitizeHTML(result.content),
            category: this.encodeHTML(result.category),
            author: this.encodeHTML(result.author),
            created_at: result.created_at,
            snippet: this.encodeHTML(result.snippet)
        }));
    }
}

// Secure API response formatting
app.get('/api/search', async (req, res) => {
    try {
        // ... input validation code ...
        
        const rawResults = await executeSecureSearch(validatedParams);
        
        // Sanitize output before sending to client
        const sanitizedResults = OutputEncoder.sanitizeSearchResults(rawResults);
        
        // Additional response security headers
        res.set({
            'Content-Type': 'application/json; charset=utf-8',
            'X-Content-Type-Options': 'nosniff',
            'X-Frame-Options': 'DENY',
            'X-XSS-Protection': '1; mode=block'
        });
        
        res.json({
            success: true,
            results: sanitizedResults,
            total: sanitizedResults.length,
            query: OutputEncoder.encodeHTML(validatedParams.searchTerm)
        });
        
    } catch (error) {
        console.error('Search error:', error);
        
        // Don't leak internal error details
        res.status(500).json({
            success: false,
            error: 'Search operation failed',
            // Only include error ID for debugging, not sensitive details
            errorId: require('crypto').randomUUID()
        });
    }
});
                    </div>
                </div>

                <div id="database-security" class="tab-content">
                    <h3>Database Security Configuration</h3>
                    <div class="code-block">
// Database connection security
const pgConfig = {
    host: process.env.DB_HOST,
    port: process.env.DB_PORT || 5432,
    database: process.env.DB_NAME,
    user: process.env.DB_USER, // Use read-only user for search operations
    password: process.env.DB_PASSWORD,
    
    // SSL configuration
    ssl: {
        rejectUnauthorized: true,
        ca: fs.readFileSync('./certs/server-ca.pem').toString(),
        key: fs.readFileSync('./certs/client-key.pem').toString(),
        cert: fs.readFileSync('./certs/client-cert.pem').toString()
    },
    
    // Connection pool security
    max: 10, // Maximum number of connections
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 2000,
    
    // Query timeout
    query_timeout: 10000,
    
    // Application name for monitoring
    application_name: 'search_service'
};

// Database schema security
const createSecureSchema = async () => {
    // Create dedicated search user with minimal privileges
    await adminClient.query(`
        CREATE USER search_user WITH PASSWORD '${process.env.SEARCH_USER_PASSWORD}';
    `);
    
    // Grant only necessary permissions
    await adminClient.query(`
        GRANT CONNECT ON DATABASE search_db TO search_user;
        GRANT USAGE ON SCHEMA public TO search_user;
        GRANT SELECT ON TABLE articles, users, categories TO search_user;
        
        -- Revoke dangerous permissions
        REVOKE CREATE ON SCHEMA public FROM search_user;
        REVOKE ALL ON TABLE users FROM search_user;
        GRANT SELECT (id, username, bio) ON TABLE users TO search_user; -- Only specific columns
    `);
    
    // Create views for additional security layer
    await adminClient.query(`
        CREATE VIEW search_articles AS
        SELECT id, title, content, category, status, created_at
        FROM articles 
        WHERE status = 'published' AND deleted_at IS NULL;
        
        GRANT SELECT ON search_articles TO search_user;
    `);
    
    // Enable row-level security
    await adminClient.query(`
        ALTER TABLE articles ENABLE ROW LEVEL SECURITY;
        
        CREATE POLICY search_policy ON articles
        FOR SELECT TO search_user
        USING (status = 'published' AND deleted_at IS NULL);
    `);
};

// Query execution with security monitoring
class SecureDatabaseClient {
    constructor(config) {
        this.pool = new Pool(config);
        this.queryCount = 0;
        this.suspiciousQueries = [];
    }
    
    async query(sql, params = []) {
        const startTime = Date.now();
        this.queryCount++;
        
        try {
            // Log query for monitoring (in development only)
            if (process.env.NODE_ENV === 'development') {
                console.log('Executing query:', { sql, params });
            }
            
            // Check for suspicious patterns
            if (this.detectSuspiciousQuery(sql, params)) {
                this.logSuspiciousActivity(sql, params);
            }
            
            // Set query timeout
            const client = await this.pool.connect();
            
            try {
                await client.query('SET statement_timeout = $1', ['10s']);
                const result = await client.query(sql, params);
                
                const executionTime = Date.now() - startTime;
                
                // Log slow queries
                if (executionTime > 1000) {
                    console.warn('Slow query detected:', {
                        sql,
                        params,
                        executionTime,
                        timestamp: new Date().toISOString()
                    });
                }
                
                return result;
                
            } finally {
                client.release();
            }
            
        } catch (error) {
            // Log database errors securely
            console.error('Database query error:', {
                errorCode: error.code,
                errorMessage: error.message,
                queryHash: require('crypto').createHash('md5').update(sql).digest('hex'),
                timestamp: new Date().toISOString()
            });
            
            throw new Error('Database operation failed');
        }
    }
    
    detectSuspiciousQuery(sql, params) {
        const suspiciousPatterns = [
            /\b(DROP|DELETE|UPDATE|INSERT|ALTER|CREATE|EXEC)\b/i,
            /\b(UNION|INFORMATION_SCHEMA|SYSOBJECTS)\b/i,
            /(\bOR\b|\bAND\b).*\b(1\s*=\s*1|true|false)\b/i,
            /(--|\/\*|\*\/)/,
            /\b(SLEEP|WAITFOR|BENCHMARK)\b/i
        ];
        
        const queryString = sql + ' ' + JSON.stringify(params);
        return suspiciousPatterns.some(pattern => pattern.test(queryString));
    }
    
    logSuspiciousActivity(sql, params) {
        const suspiciousQuery = {
            sql,
            params,
            timestamp: new Date().toISOString(),
            ipAddress: this.currentRequest?.ip,
            userAgent: this.currentRequest?.get('User-Agent')
        };
        
        this.suspiciousQueries.push(suspiciousQuery);
        
        // Alert security team
        console.alert('SECURITY ALERT: Suspicious database query detected', suspiciousQuery);
        
        // If too many suspicious queries, block the connection
        if (this.suspiciousQueries.length > 5) {
            throw new Error('Too many suspicious queries detected');
        }
    }
    
    async healthCheck() {
        try {
            const result = await this.query('SELECT 1 as healthy');
            return result.rows[0].healthy === 1;
        } catch {
            return false;
        }
    }
}
                    </div>
                </div>

                <div id="monitoring" class="tab-content">
                    <h3>Security Monitoring and Logging</h3>
                    <div class="code-block">
const winston = require('winston');
const helmet = require('helmet');

// Security-focused logging configuration
const securityLogger = winston.createLogger({
    level: 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
    ),
    defaultMeta: { service: 'search-api' },
    transports: [
        new winston.transports.File({ filename: 'logs/security-error.log', level: 'error' }),
        new winston.transports.File({ filename: 'logs/security-combined.log' })
    ]
});

// Security monitoring middleware
const securityMonitoring = (req, res, next) => {
    const startTime = Date.now();
    
    // Log request details
    securityLogger.info('API Request', {
        method: req.method,
        url: req.url,
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        timestamp: new Date().toISOString()
    });
    
    // Monitor for suspicious patterns in query parameters
    const queryString = JSON.stringify(req.query).toLowerCase();
    const suspiciousPatterns = [
        'union', 'select', 'drop', 'delete', 'insert', 'update',
        'script', 'javascript:', 'onload', 'onerror',
        '../', '..\\', '/etc/passwd', 'cmd.exe'
    ];
    
    const suspiciousInput = suspiciousPatterns.some(pattern => 
        queryString.includes(pattern)
    );
    
    if (suspiciousInput) {
        securityLogger.warn('Suspicious input detected', {
            ip: req.ip,
            userAgent: req.get('User-Agent'),
            query: req.query,
            body: req.method === 'POST' ? req.body : null,
            timestamp: new Date().toISOString()
        });
    }
    
    // Track response
    res.on('finish', () => {
        const duration = Date.now() - startTime;
        
        securityLogger.info('API Response', {
            method: req.method,
            url: req.url,
            statusCode: res.statusCode,
            duration,
            ip: req.ip,
            timestamp: new Date().toISOString()
        });
        
        // Log failed authentication attempts
        if (res.statusCode === 401 || res.statusCode === 403) {
            securityLogger.warn('Authentication failure', {
                ip: req.ip,
                userAgent: req.get('User-Agent'),
                url: req.url,
                timestamp: new Date().toISOString()
            });
        }
    });
    
    next();
};

// Rate limiting with security logging
const createSecureRateLimit = (options) => {
    return rateLimit({
        ...options,
        handler: (req, res) => {
            securityLogger.warn('Rate limit exceeded', {
                ip: req.ip,
                userAgent: req.get('User-Agent'),
                url: req.url,
                timestamp: new Date().toISOString()
            });
            
            res.status(429).json({
                error: 'Too many requests',
                retryAfter: Math.round(options.windowMs / 1000)
            });
        }
    });
};

// SQL injection detection and blocking
const sqlInjectionProtection = (req, res, next) => {
    const checkPayload = (obj) => {
        const str = JSON.stringify(obj).toLowerCase();
        
        const sqlKeywords = [
            'union select', 'drop table', 'delete from', 'insert into',
            'update set', 'or 1=1', 'and 1=1', '--', '/*', '*/',
            'xp_cmdshell', 'sp_executesql', 'exec(', 'execute('
        ];
        
        return sqlKeywords.some(keyword => str.includes(keyword));
    };
    
    if (checkPayload(req.query) || checkPayload(req.body)) {
        securityLogger.error('SQL injection attempt blocked', {
            ip: req.ip,
            userAgent: req.get('User-Agent'),
            query: req.query,
            body: req.body,
            timestamp: new Date().toISOString()
        });
        
        return res.status(400).json({
            error: 'Invalid input detected'
        });
    }
    
    next();
};

// Security headers and general protection
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
            connectSrc: ["'self'"],
            fontSrc: ["'self'"],
            objectSrc: ["'none'"],
            mediaSrc: ["'self'"],
            frameSrc: ["'none'"]
        }
    },
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
    }
}));

// Apply security middleware
app.use(securityMonitoring);
app.use(sqlInjectionProtection);

// Search endpoint with comprehensive security
app.get('/api/search', 
    createSecureRateLimit({
        windowMs: 15 * 60 * 1000, // 15 minutes
        max: 100, // limit each IP to 100 requests per windowMs
        standardHeaders: true,
        legacyHeaders: false
    }),
    async (req, res) => {
        // ... secure search implementation ...
    }
);

// Security monitoring dashboard endpoint (admin only)
app.get('/admin/security-status', requireAdmin, (req, res) => {
    res.json({
        suspiciousQueries: secureDB.suspiciousQueries.length,
        recentAlerts: securityLogger.query({
            level: 'warn',
            from: new Date(Date.now() - 24 * 60 * 60 * 1000),
            until: new Date(),
            limit: 50
        }),
        databaseHealth: secureDB.healthCheck(),
        uptime: process.uptime()
    });
});

// Automated security alerts
const sendSecurityAlert = (alertType, details) => {
    securityLogger.error('SECURITY ALERT', {
        alertType,
        details,
        timestamp: new Date().toISOString()
    });
    
    // In production, integrate with services like:
    // - Slack/Teams notifications
    // - Email alerts
    // - PagerDuty
    // - Security Information and Event Management (SIEM) systems
};
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Attack payloads for demonstration
        const attackPayloads = {
            classic: "'; DROP TABLE users; --",
            union: "' UNION SELECT username, password FROM users --",
            blind: "' AND (SELECT COUNT(*) FROM users) > 0 --",
            time: "'; WAITFOR DELAY '00:00:10'; --",
            'second-order': "admin'; INSERT INTO posts (content) VALUES ('hacked'); --",
            privilege: "'; GRANT ALL PRIVILEGES ON *.* TO 'attacker'@'%'; --"
        };

        function showTab(tabName) {
            // Hide all main tab contents
            document.querySelectorAll('.section:nth-child(4) .tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from main tabs
            document.querySelectorAll('.section:nth-child(4) .tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }

        function showSecurityTab(tabName) {
            // Hide all security tab contents
            document.querySelectorAll('.section:nth-child(5) .tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from security tabs
            document.querySelectorAll('.section:nth-child(5) .tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }

        function updateAttackExample() {
            const attackType = document.getElementById('attack-type').value;
            const payload = attackPayloads[attackType] || '';
            document.getElementById('attack-payload').value = payload;
        }

        function simulateAttack() {
            const attackType = document.getElementById('attack-type').value;
            const payload = document.getElementById('attack-payload').value;
            const targetField = document.getElementById('target-field').value;
            
            let vulnerableQuery = '';
            let impact = '';
            
            switch (attackType) {
                case 'classic':
                    vulnerableQuery = `SELECT * FROM users WHERE ${targetField} = '${payload}'`;
                    impact = 'CRITICAL: Could drop tables, delete data, or bypass authentication';
                    break;
                case 'union':
                    vulnerableQuery = `SELECT title, content FROM articles WHERE title LIKE '%${payload}%'`;
                    impact = 'SEVERE: Could expose sensitive data from other tables';
                    break;
                case 'blind':
                    vulnerableQuery = `SELECT * FROM users WHERE ${targetField} = '${payload}'`;
                    impact = 'MODERATE: Could extract database structure and data bit by bit';
                    break;
                case 'time':
                    vulnerableQuery = `SELECT * FROM users WHERE ${targetField} = '${payload}'`;
                    impact = 'MODERATE: Could cause denial of service and extract data';
                    break;
                case 'second-order':
                    vulnerableQuery = `INSERT INTO users (username) VALUES ('${payload}')`;
                    impact = 'SEVERE: Stored malicious data could execute later';
                    break;
                case 'privilege':
                    vulnerableQuery = `SELECT * FROM users WHERE ${targetField} = '${payload}'`;
                    impact = 'CRITICAL: Could escalate database privileges';
                    break;
            }
            
            const output = `‚ùå VULNERABLE QUERY EXECUTION:
            
Query: ${vulnerableQuery}

üö® SECURITY IMPACT: ${impact}

‚ö†Ô∏è ATTACK SUCCESSFUL: This demonstrates why string concatenation is dangerous!

The malicious payload would be executed as SQL code, potentially:
- Exposing sensitive data
- Modifying or deleting records
- Compromising the entire database
- Gaining unauthorized system access`;

            document.getElementById('attack-results').textContent = output;
        }

        function demonstrateDefense() {
            const attackType = document.getElementById('attack-type').value;
            const payload = document.getElementById('attack-payload').value;
            const defenseMethod = document.getElementById('defense-method').value;
            const dbType = document.getElementById('database-type').value;
            
            let safeQuery = '';
            let safeParams = [];
            let explanation = '';
            
            const paramPlaceholder = dbType === 'postgresql' ? '$1' : '?';
            
            switch (defenseMethod) {
                case 'parameterized':
                    safeQuery = `SELECT * FROM users WHERE username = ${paramPlaceholder}`;
                    safeParams = [payload];
                    explanation = 'Parameterized queries treat user input as data, not executable code';
                    break;
                case 'validation':
                    const isValid = /^[a-zA-Z0-9_-]{3,20}$/.test(payload);
                    explanation = isValid ? 
                        'Input passed validation and can be safely used' :
                        'Input REJECTED by validation - contains invalid characters';
                    safeQuery = isValid ? `SELECT * FROM users WHERE username = ${paramPlaceholder}` : 'QUERY BLOCKED';
                    safeParams = isValid ? [payload] : [];
                    break;
                case 'sanitization':
                    const sanitized = payload.replace(/['"`;\\]/g, '').replace(/\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION)\b/gi, '').trim();
                    safeQuery = `SELECT * FROM users WHERE username = ${paramPlaceholder}`;
                    safeParams = [sanitized];
                    explanation = `Input sanitized: "${payload}" ‚Üí "${sanitized}"`;
                    break;
                case 'whitelist':
                    const allowedValues = ['admin', 'user', 'guest', 'moderator'];
                    const isAllowed = allowedValues.includes(payload.toLowerCase());
                    explanation = isAllowed ?
                        'Input found in whitelist - safe to use' :
                        'Input NOT in whitelist - query blocked';
                    safeQuery = isAllowed ? `SELECT * FROM users WHERE username = ${paramPlaceholder}` : 'QUERY BLOCKED';
                    safeParams = isAllowed ? [payload] : [];
                    break;
                case 'escaping':
                    const escaped = payload.replace(/'/g, "''").replace(/\\/g, '\\\\');
                    safeQuery = `SELECT * FROM users WHERE username = '${escaped}'`;
                    explanation = `Input properly escaped: "${payload}" ‚Üí "${escaped}"`;
                    break;
            }
            
            const output = `‚úÖ SECURE DEFENSE IMPLEMENTATION:

Defense Method: ${defenseMethod.toUpperCase()}
Database: ${dbType.toUpperCase()}

Safe Query: ${safeQuery}
Parameters: ${JSON.stringify(safeParams, null, 2)}

üõ°Ô∏è PROTECTION EXPLANATION:
${explanation}

üîí RESULT: The malicious payload is safely handled and cannot execute as SQL code.
The attack is neutralized and the application remains secure.`;

            document.getElementById('defense-results').textContent = output;
        }

        // Initialize demo on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateAttackExample();
            simulateAttack();
            demonstrateDefense();
        });
    </script>
</body>
</html>