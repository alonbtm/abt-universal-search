<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Performance Optimization Examples - Universal Search Component</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .example-section {
            margin: 30px 0;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f9f9f9;
        }
        .performance-tip {
            background: #e8f5e8;
            color: #2e7d32;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
            border-left: 4px solid #4caf50;
        }
        .config-display {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 6px;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 14px;
            overflow-x: auto;
        }
        .optimization-example {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            background: white;
        }
        .optimization-title {
            font-weight: 600;
            color: #1976d2;
            margin-bottom: 10px;
        }
        .benchmark-result {
            background: #f0f8ff;
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid #2196f3;
            margin: 10px 0;
        }
        .warning {
            background: #fff3e0;
            color: #e65100;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
            border-left: 4px solid #ff9800;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
        .query-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .slow-query, .fast-query {
            padding: 15px;
            border-radius: 6px;
        }
        .slow-query {
            background: #ffebee;
            border-left: 4px solid #f44336;
        }
        .fast-query {
            background: #e8f5e8;
            border-left: 4px solid #4caf50;
        }
    </style>
</head>
<body>
    <h1>SQL Performance Optimization Examples</h1>
    
    <div class="example-section">
        <h2>üöÄ Query Optimization Strategies</h2>
        <p>Learn how to optimize SQL queries for better search performance across different database systems.</p>
        
        <div class="performance-tip">
            <strong>Performance Tip:</strong> Always use proper indexing strategies for your searchable fields to achieve sub-100ms query response times.
        </div>
    </div>

    <div class="example-section">
        <h2>üìä Index Usage Demonstrations</h2>
        
        <div class="optimization-example">
            <div class="optimization-title">PostgreSQL Full-Text Search with TSVECTOR</div>
            <p>PostgreSQL's full-text search capabilities with GIN indexes provide excellent performance for text searches.</p>
            
            <div class="config-display">-- Create table with TSVECTOR index
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    category TEXT,
    search_vector TSVECTOR
);

-- Create GIN index for full-text search
CREATE INDEX idx_products_search ON products 
USING gin(to_tsvector('english', name || ' ' || description));

-- Update trigger to maintain search_vector
CREATE OR REPLACE FUNCTION update_search_vector()
RETURNS TRIGGER AS $$
BEGIN
    NEW.search_vector = to_tsvector('english', NEW.name || ' ' || NEW.description);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsvector_update 
BEFORE INSERT OR UPDATE ON products 
FOR EACH ROW EXECUTE FUNCTION update_search_vector();</div>
            
            <div class="query-comparison">
                <div class="slow-query">
                    <strong>‚ùå Slow Query (Table Scan)</strong>
                    <div class="config-display">-- Without index: ~500ms for 1M rows
SELECT * FROM products 
WHERE name ILIKE '%search term%' 
   OR description ILIKE '%search term%'
LIMIT 20;</div>
                </div>
                <div class="fast-query">
                    <strong>‚úÖ Fast Query (Index Scan)</strong>
                    <div class="config-display">-- With GIN index: ~5ms for 1M rows
SELECT * FROM products 
WHERE search_vector @@ to_tsquery('english', 'search & term')
ORDER BY ts_rank(search_vector, to_tsquery('english', 'search & term')) DESC
LIMIT 20;</div>
                </div>
            </div>
            
            <div class="benchmark-result">
                <strong>Performance Results:</strong>
                <ul>
                    <li>Without index: ~500ms average query time</li>
                    <li>With GIN index: ~5ms average query time</li>
                    <li>Performance improvement: 100x faster</li>
                    <li>Index size: ~15% of table size</li>
                </ul>
            </div>
        </div>

        <div class="optimization-example">
            <div class="optimization-title">MySQL FULLTEXT Index Optimization</div>
            <p>MySQL's FULLTEXT indexes provide natural language and boolean search modes for optimal performance.</p>
            
            <div class="config-display">-- Create table with FULLTEXT index
CREATE TABLE articles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT,
    tags VARCHAR(500),
    FULLTEXT(title, content, tags)
) ENGINE=InnoDB;

-- Natural language search (fastest)
SELECT id, title, 
       MATCH(title, content, tags) AGAINST('search terms') AS relevance
FROM articles
WHERE MATCH(title, content, tags) AGAINST('search terms')
ORDER BY relevance DESC
LIMIT 20;

-- Boolean search (more flexible)
SELECT id, title
FROM articles
WHERE MATCH(title, content, tags) AGAINST('+search +terms -exclude' IN BOOLEAN MODE)
LIMIT 20;</div>
            
            <div class="benchmark-result">
                <strong>MySQL FULLTEXT Performance:</strong>
                <ul>
                    <li>Natural language mode: ~2ms for 100K rows</li>
                    <li>Boolean mode: ~8ms for 100K rows</li>
                    <li>LIKE queries: ~150ms for 100K rows</li>
                    <li>Recommended minimum word length: 4 characters</li>
                </ul>
            </div>
        </div>

        <div class="optimization-example">
            <div class="optimization-title">SQLite FTS (Full-Text Search) Virtual Tables</div>
            <p>SQLite's FTS5 extension provides excellent search performance for client-side applications.</p>
            
            <div class="config-display">-- Create FTS5 virtual table
CREATE VIRTUAL TABLE documents_fts USING fts5(
    title,
    content,
    tags,
    content_rowid=id
);

-- Create regular table for other data
CREATE TABLE documents (
    id INTEGER PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT,
    tags TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Trigger to keep FTS table in sync
CREATE TRIGGER documents_ai AFTER INSERT ON documents BEGIN
    INSERT INTO documents_fts(rowid, title, content, tags) 
    VALUES (new.id, new.title, new.content, new.tags);
END;

-- Fast FTS5 search with ranking
SELECT d.*, rank
FROM documents d
JOIN (
    SELECT rowid, bm25(documents_fts, 1.0, 0.5, 0.3) AS rank
    FROM documents_fts
    WHERE documents_fts MATCH 'search terms'
    ORDER BY rank
    LIMIT 20
) fts ON d.id = fts.rowid;</div>
            
            <div class="benchmark-result">
                <strong>SQLite FTS5 Performance:</strong>
                <ul>
                    <li>FTS5 search: ~1ms for 50K rows</li>
                    <li>LIKE queries: ~25ms for 50K rows</li>
                    <li>BM25 ranking available</li>
                    <li>Excellent for embedded/client-side use</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="example-section">
        <h2>üîß Universal Search Component Configuration</h2>
        <p>Configure the search component for optimal performance across different database systems.</p>
        
        <div id="performance-demo" style="margin: 20px 0;"></div>
        
        <div class="performance-tip">
            <strong>Configuration Tip:</strong> Always set appropriate result limits and use connection pooling for production deployments.
        </div>
    </div>

    <div class="example-section">
        <h2>‚ö° Connection Pooling and Resource Management</h2>
        
        <div class="optimization-example">
            <div class="optimization-title">Connection Pool Configuration</div>
            <p>Proper connection pooling prevents connection overhead and ensures optimal resource utilization.</p>
            
            <div class="config-display">// PostgreSQL Connection Pool Configuration
const poolConfig = {
    connectionString: process.env.DATABASE_URL,
    max: 20,                    // Maximum connections
    min: 5,                     // Minimum connections  
    idleTimeoutMillis: 30000,   // Close idle connections after 30s
    connectionTimeoutMillis: 2000, // Fail fast if can't connect
    maxUses: 7500,              // Rotate connections after 7500 uses
    application_name: 'universal-search',
    statement_timeout: 5000,     // Query timeout: 5 seconds
    query_timeout: 5000,
    keepAlive: true,
    keepAliveInitialDelayMillis: 10000
};

// MySQL Connection Pool
const mysqlPool = mysql.createPool({
    connectionLimit: 20,
    host: process.env.MYSQL_HOST,
    user: process.env.MYSQL_USER,
    password: process.env.MYSQL_PASSWORD,
    database: process.env.MYSQL_DATABASE,
    acquireTimeout: 60000,
    timeout: 60000,
    reconnect: true,
    charset: 'utf8mb4'
});

// SQLite with WAL mode for better concurrency
const sqliteConfig = {
    filename: './database.sqlite',
    mode: sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE,
    options: {
        'journal_mode': 'WAL',      // Write-Ahead Logging
        'synchronous': 'NORMAL',    // Balance safety/speed
        'cache_size': -64000,       // 64MB cache
        'temp_store': 'MEMORY',     // Use memory for temp storage
        'mmap_size': 268435456      // 256MB memory-mapped I/O
    }
};</div>
        </div>
    </div>

    <div class="example-section">
        <h2>üìà Query Performance Monitoring</h2>
        
        <div class="optimization-example">
            <div class="optimization-title">Performance Metrics and Logging</div>
            <p>Monitor query performance to identify bottlenecks and optimize accordingly.</p>
            
            <div class="config-display">// Query performance monitoring wrapper
class PerformanceMonitor {
    static async measureQuery(queryName: string, queryFn: () => Promise<any>) {
        const startTime = performance.now();
        const startMemory = process.memoryUsage().heapUsed;
        
        try {
            const result = await queryFn();
            const endTime = performance.now();
            const endMemory = process.memoryUsage().heapUsed;
            
            const metrics = {
                query: queryName,
                duration: endTime - startTime,
                memoryDelta: endMemory - startMemory,
                resultCount: Array.isArray(result) ? result.length : 1,
                timestamp: new Date().toISOString()
            };
            
            // Log slow queries (>100ms)
            if (metrics.duration > 100) {
                console.warn('Slow query detected:', metrics);
            }
            
            // Store metrics for analysis
            this.recordMetrics(metrics);
            
            return result;
        } catch (error) {
            console.error('Query failed:', queryName, error);
            throw error;
        }
    }
    
    static recordMetrics(metrics: QueryMetrics) {
        // Store in monitoring system (e.g., StatsD, CloudWatch)
        // Example: statsd.timing('query.duration', metrics.duration, [`query:${metrics.query}`]);
    }
}

// Usage example
const searchResults = await PerformanceMonitor.measureQuery(
    'products_search',
    () => searchProducts(query, filters, pagination)
);</div>
        </div>
    </div>

    <div class="example-section">
        <h2>‚ö†Ô∏è Performance Best Practices</h2>
        
        <div class="warning">
            <strong>Important:</strong> Always test performance optimizations with realistic data volumes and query patterns.
        </div>
        
        <table>
            <thead>
                <tr>
                    <th>Database</th>
                    <th>Best Practice</th>
                    <th>Expected Performance</th>
                    <th>Index Strategy</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>PostgreSQL</td>
                    <td>Use TSVECTOR with GIN indexes</td>
                    <td>&lt; 10ms for 1M+ rows</td>
                    <td>GIN index on search columns</td>
                </tr>
                <tr>
                    <td>MySQL</td>
                    <td>FULLTEXT indexes in InnoDB</td>
                    <td>&lt; 5ms for 100K+ rows</td>
                    <td>FULLTEXT on search fields</td>
                </tr>
                <tr>
                    <td>SQLite</td>
                    <td>FTS5 virtual tables</td>
                    <td>&lt; 2ms for 50K+ rows</td>
                    <td>FTS5 with BM25 ranking</td>
                </tr>
            </tbody>
        </table>
        
        <div class="performance-tip">
            <strong>Production Checklist:</strong>
            <ul>
                <li>‚úÖ Implement proper indexing strategy</li>
                <li>‚úÖ Configure connection pooling</li>
                <li>‚úÖ Set query timeouts (5 seconds max)</li>
                <li>‚úÖ Limit result sets (max 100 results)</li>
                <li>‚úÖ Monitor query performance</li>
                <li>‚úÖ Use parameterized queries</li>
                <li>‚úÖ Implement result caching</li>
            </ul>
        </div>
    </div>

    <script>
        // Interactive performance demonstration
        class SQLPerformanceDemo {
            constructor() {
                this.initializeDemo();
            }
            
            initializeDemo() {
                const container = document.getElementById('performance-demo');
                if (!container) return;
                
                container.innerHTML = `
                    <div class="optimization-example">
                        <div class="optimization-title">Interactive Performance Comparison</div>
                        <p>Compare query performance across different optimization strategies:</p>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 20px 0;">
                            <button id="test-unoptimized" class="test-button" style="padding: 10px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                Test Unoptimized Query
                            </button>
                            <button id="test-indexed" class="test-button" style="padding: 10px; background: #ff9800; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                Test Indexed Query
                            </button>
                            <button id="test-fulltext" class="test-button" style="padding: 10px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                Test Full-Text Search
                            </button>
                        </div>
                        
                        <div id="performance-results" style="margin-top: 20px;"></div>
                    </div>
                `;
                
                this.bindEvents();
            }
            
            bindEvents() {
                document.getElementById('test-unoptimized')?.addEventListener('click', () => {
                    this.simulateQuery('Unoptimized LIKE Query', 450, '#f44336');
                });
                
                document.getElementById('test-indexed')?.addEventListener('click', () => {
                    this.simulateQuery('B-tree Index Query', 25, '#ff9800');
                });
                
                document.getElementById('test-fulltext')?.addEventListener('click', () => {
                    this.simulateQuery('Full-Text Search', 3, '#4caf50');
                });
            }
            
            simulateQuery(queryType, baseTime, color) {
                const resultsDiv = document.getElementById('performance-results');
                if (!resultsDiv) return;
                
                resultsDiv.innerHTML = `<div style="color: ${color}; font-weight: bold;">Running ${queryType}...</div>`;
                
                // Simulate query execution time
                const actualTime = baseTime + (Math.random() * 20 - 10); // Add some variance
                
                setTimeout(() => {
                    resultsDiv.innerHTML = `
                        <div class="benchmark-result">
                            <strong>${queryType} Results:</strong>
                            <ul>
                                <li>Query time: ${actualTime.toFixed(1)}ms</li>
                                <li>Records scanned: ${this.getRecordsScanned(queryType)}</li>
                                <li>Results returned: 20</li>
                                <li>Performance rating: ${this.getPerformanceRating(actualTime)}</li>
                            </ul>
                        </div>
                    `;
                }, actualTime * 2); // Visual delay for demonstration
            }
            
            getRecordsScanned(queryType) {
                const scans = {
                    'Unoptimized LIKE Query': '1,000,000 (full table scan)',
                    'B-tree Index Query': '~500 (index + table lookups)', 
                    'Full-Text Search': '~50 (optimized index scan)'
                };
                return scans[queryType] || 'Unknown';
            }
            
            getPerformanceRating(time) {
                if (time < 10) return 'üöÄ Excellent';
                if (time < 50) return '‚úÖ Good';
                if (time < 200) return '‚ö†Ô∏è Fair';
                return '‚ùå Poor';
            }
        }
        
        // Initialize the demo when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SQLPerformanceDemo();
        });
    </script>
</body>
</html>