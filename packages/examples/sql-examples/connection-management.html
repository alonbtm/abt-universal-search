<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Connection Management Examples - Universal Search Component</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .example-section {
            margin: 30px 0;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f9f9f9;
        }
        .best-practice {
            background: #e8f5e8;
            color: #2e7d32;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
            border-left: 4px solid #4caf50;
        }
        .config-display {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 6px;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 14px;
            overflow-x: auto;
        }
        .management-example {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            background: white;
        }
        .management-title {
            font-weight: 600;
            color: #1976d2;
            margin-bottom: 10px;
        }
        .monitoring-panel {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #2196f3;
            margin: 15px 0;
        }
        .error-example {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
            border-left: 4px solid #f44336;
        }
        .connection-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .status-healthy { background: #c8e6c9; color: #2e7d32; }
        .status-warning { background: #fff3e0; color: #f57c00; }
        .status-error { background: #ffcdd2; color: #d32f2f; }
        .code-tabs {
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        .tab-buttons {
            display: flex;
            background: #f5f5f5;
        }
        .tab-button {
            padding: 10px 20px;
            border: none;
            background: none;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        .tab-button.active {
            background: white;
            border-bottom-color: #2196f3;
            color: #2196f3;
        }
        .tab-content {
            display: none;
            padding: 15px;
            background: white;
        }
        .tab-content.active {
            display: block;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <h1>SQL Connection Management Examples</h1>
    
    <div class="example-section">
        <h2>üîó Connection Pooling Best Practices</h2>
        <p>Efficient connection pool management is crucial for application performance and database stability.</p>
        
        <div class="best-practice">
            <strong>Best Practice:</strong> Always use connection pooling in production environments to prevent connection exhaustion and improve performance.
        </div>
    </div>

    <div class="example-section">
        <h2>‚öôÔ∏è Database-Specific Connection Pools</h2>
        
        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="showTab('postgresql-pool')">PostgreSQL</button>
                <button class="tab-button" onclick="showTab('mysql-pool')">MySQL</button>
                <button class="tab-button" onclick="showTab('sqlite-pool')">SQLite</button>
            </div>
            
            <div id="postgresql-pool" class="tab-content active">
                <div class="management-title">PostgreSQL Connection Pool Configuration</div>
                <div class="config-display">import { Pool } from 'pg';

// Production-ready PostgreSQL connection pool
const pool = new Pool({
    // Connection settings
    connectionString: process.env.DATABASE_URL,
    host: process.env.POSTGRES_HOST || 'localhost',
    port: parseInt(process.env.POSTGRES_PORT || '5432'),
    database: process.env.POSTGRES_DB,
    user: process.env.POSTGRES_USER,
    password: process.env.POSTGRES_PASSWORD,
    
    // Pool configuration
    min: 5,                           // Minimum connections in pool
    max: 20,                          // Maximum connections in pool
    idleTimeoutMillis: 30000,         // Close idle connections after 30s
    connectionTimeoutMillis: 2000,    // Fail fast if can't connect
    maxUses: 7500,                    // Rotate connections after 7500 uses
    
    // Performance settings
    statement_timeout: 5000,          // Query timeout: 5 seconds
    query_timeout: 5000,              // Overall query timeout
    keepAlive: true,                  // Enable TCP keep-alive
    keepAliveInitialDelayMillis: 10000, // Keep-alive delay
    
    // Application identification
    application_name: 'universal-search',
    
    // SSL configuration for production
    ssl: process.env.NODE_ENV === 'production' ? {
        rejectUnauthorized: true,
        ca: process.env.SSL_CA,
        cert: process.env.SSL_CERT,
        key: process.env.SSL_KEY
    } : false
});

// Connection event handlers
pool.on('connect', (client) => {
    console.log('New PostgreSQL client connected');
    
    // Set timezone for all connections
    client.query('SET timezone = "UTC"');
});

pool.on('error', (err, client) => {
    console.error('Unexpected error on idle PostgreSQL client:', err);
    process.exit(-1);
});

pool.on('acquire', (client) => {
    console.log('PostgreSQL client acquired from pool');
});

pool.on('remove', (client) => {
    console.log('PostgreSQL client removed from pool');
});

// Example usage with automatic cleanup
async function executeQuery(sql: string, params: any[]): Promise<any[]> {
    const client = await pool.connect();
    try {
        const result = await client.query(sql, params);
        return result.rows;
    } finally {
        client.release(); // Always release back to pool
    }
}

// Graceful shutdown
process.on('SIGTERM', async () => {
    console.log('Closing PostgreSQL pool...');
    await pool.end();
    console.log('PostgreSQL pool closed');
});
</div>
                
                <div class="monitoring-panel">
                    <strong>PostgreSQL Pool Monitoring:</strong>
                    <ul>
                        <li><strong>pool.totalCount:</strong> Total connections in pool</li>
                        <li><strong>pool.idleCount:</strong> Idle connections available</li>
                        <li><strong>pool.waitingCount:</strong> Clients waiting for connections</li>
                    </ul>
                </div>
            </div>
            
            <div id="mysql-pool" class="tab-content">
                <div class="management-title">MySQL Connection Pool Configuration</div>
                <div class="config-display">import mysql from 'mysql2/promise';

// MySQL connection pool with comprehensive configuration
const pool = mysql.createPool({
    // Connection settings
    host: process.env.MYSQL_HOST || 'localhost',
    port: parseInt(process.env.MYSQL_PORT || '3306'),
    user: process.env.MYSQL_USER,
    password: process.env.MYSQL_PASSWORD,
    database: process.env.MYSQL_DATABASE,
    
    // Pool configuration
    connectionLimit: 20,              // Maximum connections in pool
    acquireTimeout: 60000,            // Time to wait for connection (60s)
    timeout: 60000,                   // Query timeout (60s)
    reconnect: true,                  // Automatically reconnect
    
    // Character set and collation
    charset: 'utf8mb4',               // Support emojis and international characters
    
    // SSL configuration
    ssl: process.env.NODE_ENV === 'production' ? {
        ca: process.env.SSL_CA,
        cert: process.env.SSL_CERT,
        key: process.env.SSL_KEY,
        rejectUnauthorized: true
    } : false,
    
    // Connection options
    supportBigNumbers: true,          // Support for big numbers
    bigNumberStrings: false,          // Return big numbers as strings
    dateStrings: false,               // Parse dates as Date objects
    debug: false,                     // Disable debug logging
    multipleStatements: false,        // Security: disable multiple statements
    
    // Connection flags for security
    flags: [
        '-FOUND_ROWS',                // Don't return affected rows for security
        '-IGNORE_SPACE'               // Strict SQL parsing
    ]
});

// Pool event handlers
pool.on('connection', (connection) => {
    console.log('New MySQL connection established:', connection.threadId);
    
    // Set session variables for each connection
    connection.query('SET SESSION sql_mode = "STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION"');
    connection.query('SET SESSION time_zone = "+00:00"'); // UTC
});

pool.on('error', (err) => {
    console.error('MySQL pool error:', err);
    if (err.code === 'PROTOCOL_CONNECTION_LOST') {
        console.log('Reconnecting to MySQL...');
        // Pool will automatically reconnect
    }
});

// Connection management helper
class MySQLConnectionManager {
    static async withConnection<T>(callback: (connection: any) => Promise<T>): Promise<T> {
        const connection = await pool.getConnection();
        try {
            return await callback(connection);
        } finally {
            connection.release(); // Return to pool
        }
    }
    
    static async withTransaction<T>(callback: (connection: any) => Promise<T>): Promise<T> {
        return await this.withConnection(async (connection) => {
            await connection.beginTransaction();
            try {
                const result = await callback(connection);
                await connection.commit();
                return result;
            } catch (error) {
                await connection.rollback();
                throw error;
            }
        });
    }
}

// Example usage
const searchResults = await MySQLConnectionManager.withConnection(async (connection) => {
    const [rows] = await connection.execute(
        'SELECT * FROM articles WHERE MATCH(title, content) AGAINST(? IN NATURAL LANGUAGE MODE) LIMIT ?',
        [searchTerm, limit]
    );
    return rows;
});

// Graceful shutdown
process.on('SIGTERM', async () => {
    console.log('Closing MySQL pool...');
    await pool.end();
    console.log('MySQL pool closed');
});
</div>
                
                <div class="monitoring-panel">
                    <strong>MySQL Pool Monitoring:</strong>
                    <ul>
                        <li><strong>pool._allConnections.length:</strong> Total connections</li>
                        <li><strong>pool._freeConnections.length:</strong> Available connections</li>
                        <li><strong>pool._acquiringConnections.length:</strong> Connections being acquired</li>
                    </ul>
                </div>
            </div>
            
            <div id="sqlite-pool" class="tab-content">
                <div class="management-title">SQLite Connection Management</div>
                <div class="config-display">import sqlite3 from 'sqlite3';
import { Database, open } from 'sqlite';

// SQLite connection manager with connection pooling simulation
class SQLiteConnectionManager {
    private static connections: Map<string, Database> = new Map();
    private static connectionPromises: Map<string, Promise<Database>> = new Map();
    private static maxConnections = 5; // SQLite limitation - use fewer connections
    
    static async getConnection(filename: string = './database.sqlite'): Promise<Database> {
        // Check if connection already exists
        if (this.connections.has(filename)) {
            return this.connections.get(filename)!;
        }
        
        // Check if connection is being created
        if (this.connectionPromises.has(filename)) {
            return await this.connectionPromises.get(filename)!;
        }
        
        // Create new connection
        const connectionPromise = this.createConnection(filename);
        this.connectionPromises.set(filename, connectionPromise);
        
        try {
            const connection = await connectionPromise;
            this.connections.set(filename, connection);
            return connection;
        } finally {
            this.connectionPromises.delete(filename);
        }
    }
    
    private static async createConnection(filename: string): Promise<Database> {
        const db = await open({
            filename,
            driver: sqlite3.Database
        });
        
        // Configure SQLite for optimal performance and concurrency
        await db.exec(`
            -- Enable WAL mode for better concurrency
            PRAGMA journal_mode = WAL;
            
            -- Set synchronous mode for balance of safety and speed
            PRAGMA synchronous = NORMAL;
            
            -- Increase cache size to 64MB
            PRAGMA cache_size = -64000;
            
            -- Use memory for temporary storage
            PRAGMA temp_store = MEMORY;
            
            -- Enable memory-mapped I/O (256MB)
            PRAGMA mmap_size = 268435456;
            
            -- Set busy timeout to 30 seconds
            PRAGMA busy_timeout = 30000;
            
            -- Optimize for small transactions
            PRAGMA optimize;
        `);
        
        console.log(`SQLite connection opened: ${filename}`);
        
        return db;
    }
    
    static async closeConnection(filename: string): Promise<void> {
        const connection = this.connections.get(filename);
        if (connection) {
            await connection.close();
            this.connections.delete(filename);
            console.log(`SQLite connection closed: ${filename}`);
        }
    }
    
    static async closeAllConnections(): Promise<void> {
        const closePromises = Array.from(this.connections.entries()).map(
            ([filename, connection]) => this.closeConnection(filename)
        );
        await Promise.all(closePromises);
    }
    
    // Execute query with automatic connection management
    static async execute<T>(
        filename: string,
        callback: (db: Database) => Promise<T>
    ): Promise<T> {
        const connection = await this.getConnection(filename);
        return await callback(connection);
    }
    
    // Execute transaction
    static async transaction<T>(
        filename: string,
        callback: (db: Database) => Promise<T>
    ): Promise<T> {
        return await this.execute(filename, async (db) => {
            await db.exec('BEGIN TRANSACTION');
            try {
                const result = await callback(db);
                await db.exec('COMMIT');
                return result;
            } catch (error) {
                await db.exec('ROLLBACK');
                throw error;
            }
        });
    }
}

// Example usage with FTS5
const searchResults = await SQLiteConnectionManager.execute('./search.db', async (db) => {
    return await db.all(`
        SELECT d.*, bm25(fts, 1.0, 0.5, 0.3) as relevance_score
        FROM documents d
        JOIN (
            SELECT rowid
            FROM documents_fts fts
            WHERE documents_fts MATCH ?
            ORDER BY bm25(documents_fts, 1.0, 0.5, 0.3)
            LIMIT ?
        ) fts ON d.id = fts.rowid
        ORDER BY relevance_score
    `, [searchTerm, limit]);
});

// Graceful shutdown
process.on('SIGTERM', async () => {
    console.log('Closing SQLite connections...');
    await SQLiteConnectionManager.closeAllConnections();
    console.log('SQLite connections closed');
});
</div>
                
                <div class="monitoring-panel">
                    <strong>SQLite Connection Monitoring:</strong>
                    <ul>
                        <li><strong>Active Connections:</strong> Track open database handles</li>
                        <li><strong>WAL Size:</strong> Monitor Write-Ahead Log size</li>
                        <li><strong>Page Cache:</strong> Monitor cache hit ratio</li>
                        <li><strong>Lock Contention:</strong> Monitor busy timeout events</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="example-section">
        <h2>üîÑ Connection Retry and Error Recovery</h2>
        
        <div class="management-example">
            <div class="management-title">Robust Connection Retry Logic</div>
            <div class="config-display">class ConnectionRetryManager {
    private static readonly DEFAULT_RETRY_CONFIG = {
        maxRetries: 3,
        baseDelayMs: 1000,
        maxDelayMs: 30000,
        backoffFactor: 2,
        jitterMs: 100
    };
    
    static async withRetry<T>(
        operation: () => Promise<T>,
        config = this.DEFAULT_RETRY_CONFIG
    ): Promise<T> {
        let lastError: Error;
        
        for (let attempt = 1; attempt <= config.maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                lastError = error as Error;
                
                // Don't retry on authentication or permission errors
                if (this.isNonRetryableError(error)) {
                    throw error;
                }
                
                if (attempt === config.maxRetries) {
                    console.error(`Operation failed after ${config.maxRetries} attempts:`, error);
                    break;
                }
                
                // Calculate delay with exponential backoff and jitter
                const delay = Math.min(
                    config.baseDelayMs * Math.pow(config.backoffFactor, attempt - 1),
                    config.maxDelayMs
                ) + (Math.random() * config.jitterMs);
                
                console.warn(`Attempt ${attempt} failed, retrying in ${Math.round(delay)}ms:`, error.message);
                await this.delay(delay);
            }
        }
        
        throw lastError;
    }
    
    private static isNonRetryableError(error: any): boolean {
        const nonRetryableCodes = [
            'AUTHENTICATION_FAILED',
            'PERMISSION_DENIED',
            'INVALID_CREDENTIALS',
            'ACCESS_DENIED',
            'INVALID_DATABASE',
            'SYNTAX_ERROR'
        ];
        
        return nonRetryableCodes.some(code => 
            error.message?.includes(code) || 
            error.code === code
        );
    }
    
    private static delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// Usage example
const results = await ConnectionRetryManager.withRetry(async () => {
    const connection = await pool.connect();
    try {
        return await connection.query(sql, params);
    } finally {
        connection.release();
    }
});
</div>
        </div>
        
        <div class="error-example">
            <strong>Common Connection Errors and Recovery:</strong>
            <ul>
                <li><strong>ECONNREFUSED:</strong> Database server not running - retry with backoff</li>
                <li><strong>PROTOCOL_CONNECTION_LOST:</strong> Connection dropped - automatic reconnection</li>
                <li><strong>ER_CON_COUNT_ERROR:</strong> Too many connections - implement queue or circuit breaker</li>
                <li><strong>SQLITE_BUSY:</strong> Database locked - retry with shorter intervals</li>
            </ul>
        </div>
    </div>

    <div class="example-section">
        <h2>üè• Health Checks and Monitoring</h2>
        
        <div class="management-example">
            <div class="management-title">Comprehensive Health Check Implementation</div>
            <div id="health-monitor" style="margin: 20px 0;"></div>
            
            <div class="config-display">interface HealthCheck {
    name: string;
    status: 'healthy' | 'warning' | 'error';
    responseTime: number;
    details?: any;
    timestamp: string;
}

class DatabaseHealthMonitor {
    private healthChecks: Map<string, HealthCheck> = new Map();
    private monitoringInterval: NodeJS.Timeout | null = null;
    
    async startMonitoring(intervalMs: number = 30000): Promise<void> {
        // Run initial health checks
        await this.runAllHealthChecks();
        
        // Set up periodic monitoring
        this.monitoringInterval = setInterval(async () => {
            await this.runAllHealthChecks();
        }, intervalMs);
        
        console.log(`Database health monitoring started (${intervalMs}ms interval)`);
    }
    
    stopMonitoring(): void {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
            console.log('Database health monitoring stopped');
        }
    }
    
    async runAllHealthChecks(): Promise<Map<string, HealthCheck>> {
        const checks = [
            this.checkPostgreSQLHealth(),
            this.checkMySQLHealth(),
            this.checkSQLiteHealth()
        ];
        
        await Promise.allSettled(checks);
        return this.healthChecks;
    }
    
    private async checkPostgreSQLHealth(): Promise<void> {
        const startTime = Date.now();
        
        try {
            const client = await pool.connect();
            
            // Test basic connectivity
            await client.query('SELECT 1');
            
            // Check pool statistics
            const poolStats = {
                totalCount: pool.totalCount,
                idleCount: pool.idleCount,
                waitingCount: pool.waitingCount
            };
            
            client.release();
            
            const responseTime = Date.now() - startTime;
            const status = responseTime > 1000 ? 'warning' : 'healthy';
            
            this.healthChecks.set('postgresql', {
                name: 'PostgreSQL',
                status,
                responseTime,
                details: { poolStats },
                timestamp: new Date().toISOString()
            });
            
        } catch (error) {
            this.healthChecks.set('postgresql', {
                name: 'PostgreSQL',
                status: 'error',
                responseTime: Date.now() - startTime,
                details: { error: error.message },
                timestamp: new Date().toISOString()
            });
        }
    }
    
    private async checkMySQLHealth(): Promise<void> {
        const startTime = Date.now();
        
        try {
            const connection = await mysqlPool.getConnection();
            
            // Test basic connectivity and get server status
            const [statusRows] = await connection.execute('SHOW STATUS LIKE "Threads%"');
            
            connection.release();
            
            const responseTime = Date.now() - startTime;
            const status = responseTime > 1000 ? 'warning' : 'healthy';
            
            this.healthChecks.set('mysql', {
                name: 'MySQL',
                status,
                responseTime,
                details: { 
                    serverStatus: statusRows,
                    poolStats: {
                        allConnections: mysqlPool._allConnections?.length || 0,
                        freeConnections: mysqlPool._freeConnections?.length || 0
                    }
                },
                timestamp: new Date().toISOString()
            });
            
        } catch (error) {
            this.healthChecks.set('mysql', {
                name: 'MySQL',
                status: 'error',
                responseTime: Date.now() - startTime,
                details: { error: error.message },
                timestamp: new Date().toISOString()
            });
        }
    }
    
    private async checkSQLiteHealth(): Promise<void> {
        const startTime = Date.now();
        
        try {
            const db = await SQLiteConnectionManager.getConnection();
            
            // Test basic connectivity and get database stats
            const stats = await db.get(`
                SELECT 
                    (SELECT COUNT(*) FROM sqlite_master WHERE type='table') as table_count,
                    (SELECT page_count FROM pragma_page_count()) as page_count,
                    (SELECT page_size FROM pragma_page_size()) as page_size
            `);
            
            const responseTime = Date.now() - startTime;
            const status = responseTime > 500 ? 'warning' : 'healthy';
            
            this.healthChecks.set('sqlite', {
                name: 'SQLite',
                status,
                responseTime,
                details: { 
                    databaseStats: stats,
                    connectionCount: SQLiteConnectionManager.connections.size
                },
                timestamp: new Date().toISOString()
            });
            
        } catch (error) {
            this.healthChecks.set('sqlite', {
                name: 'SQLite',
                status: 'error',
                responseTime: Date.now() - startTime,
                details: { error: error.message },
                timestamp: new Date().toISOString()
            });
        }
    }
    
    getHealthStatus(): any {
        const checks = Array.from(this.healthChecks.values());
        const overallStatus = checks.some(check => check.status === 'error') ? 'error' :
                             checks.some(check => check.status === 'warning') ? 'warning' : 'healthy';
        
        return {
            overall: overallStatus,
            checks: Object.fromEntries(this.healthChecks),
            timestamp: new Date().toISOString()
        };
    }
}

// Initialize health monitoring
const healthMonitor = new DatabaseHealthMonitor();
healthMonitor.startMonitoring(30000); // Check every 30 seconds

// Express endpoint for health status
app.get('/api/health', (req, res) => {
    const health = healthMonitor.getHealthStatus();
    const statusCode = health.overall === 'healthy' ? 200 :
                       health.overall === 'warning' ? 200 : 503;
    
    res.status(statusCode).json(health);
});
</div>
        </div>
    </div>

    <div class="example-section">
        <h2>üìä Connection Performance Metrics</h2>
        
        <table>
            <thead>
                <tr>
                    <th>Database</th>
                    <th>Recommended Pool Size</th>
                    <th>Connection Timeout</th>
                    <th>Idle Timeout</th>
                    <th>Health Check Interval</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>PostgreSQL</td>
                    <td>5-20 connections</td>
                    <td>2 seconds</td>
                    <td>30 seconds</td>
                    <td>30 seconds</td>
                </tr>
                <tr>
                    <td>MySQL</td>
                    <td>10-20 connections</td>
                    <td>60 seconds</td>
                    <td>60 seconds</td>
                    <td>30 seconds</td>
                </tr>
                <tr>
                    <td>SQLite</td>
                    <td>1-3 connections</td>
                    <td>5 seconds</td>
                    <td>300 seconds</td>
                    <td>60 seconds</td>
                </tr>
            </tbody>
        </table>
        
        <div class="best-practice">
            <strong>Production Checklist:</strong>
            <ul>
                <li>‚úÖ Configure appropriate connection pool sizes</li>
                <li>‚úÖ Implement connection retry logic with backoff</li>
                <li>‚úÖ Set up health monitoring and alerting</li>
                <li>‚úÖ Configure timeout values appropriately</li>
                <li>‚úÖ Enable connection pooling event logging</li>
                <li>‚úÖ Implement graceful shutdown procedures</li>
                <li>‚úÖ Monitor connection metrics in production</li>
            </ul>
        </div>
    </div>

    <script>
        function showTab(tabId) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabId).classList.add('active');
            event.target.classList.add('active');
        }
        
        // Initialize health monitor display
        class HealthMonitorDemo {
            constructor() {
                this.initializeHealthMonitor();
                this.startSimulation();
            }
            
            initializeHealthMonitor() {
                const container = document.getElementById('health-monitor');
                if (!container) return;
                
                container.innerHTML = `
                    <div class="monitoring-panel">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <strong>Real-time Database Health Status</strong>
                            <button onclick="healthDemo.refreshHealth()" style="padding: 5px 10px; background: #2196f3; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                Refresh Status
                            </button>
                        </div>
                        <div id="health-status"></div>
                    </div>
                `;
            }
            
            startSimulation() {
                this.updateHealthStatus();
                setInterval(() => this.updateHealthStatus(), 5000);
            }
            
            updateHealthStatus() {
                const statusContainer = document.getElementById('health-status');
                if (!statusContainer) return;
                
                // Simulate health check results
                const databases = [
                    { 
                        name: 'PostgreSQL', 
                        status: Math.random() > 0.1 ? 'healthy' : 'warning',
                        responseTime: Math.round(Math.random() * 50 + 5),
                        connections: { active: Math.round(Math.random() * 10 + 2), idle: Math.round(Math.random() * 5 + 3) }
                    },
                    { 
                        name: 'MySQL', 
                        status: Math.random() > 0.15 ? 'healthy' : 'error',
                        responseTime: Math.round(Math.random() * 30 + 8),
                        connections: { active: Math.round(Math.random() * 8 + 1), idle: Math.round(Math.random() * 4 + 2) }
                    },
                    { 
                        name: 'SQLite', 
                        status: 'healthy',
                        responseTime: Math.round(Math.random() * 10 + 1),
                        connections: { active: 1, idle: 0 }
                    }
                ];
                
                const statusHTML = databases.map(db => `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; margin: 5px 0; border: 1px solid #ddd; border-radius: 4px; background: white;">
                        <div>
                            <strong>${db.name}</strong>
                            <span class="connection-status status-${db.status}">${db.status}</span>
                        </div>
                        <div style="text-align: right; font-size: 12px; color: #666;">
                            <div>Response: ${db.responseTime}ms</div>
                            <div>Connections: ${db.connections.active} active, ${db.connections.idle} idle</div>
                        </div>
                    </div>
                `).join('');
                
                statusContainer.innerHTML = statusHTML;
            }
            
            refreshHealth() {
                this.updateHealthStatus();
                console.log('Health status refreshed');
            }
        }
        
        // Initialize demo when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.healthDemo = new HealthMonitorDemo();
        });
    </script>
</body>
</html>